<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>
    <title>ãƒ•ãƒ«æ©Ÿèƒ½ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ã‚¿ãƒ¼ï¼ˆEQ/ãƒªãƒãƒ¼ãƒ–/ãƒ‡ã‚£ãƒ¬ã‚¤/ãƒ‘ãƒ³/ã‚³ãƒ³ãƒ—ï¼‹ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ï¼‰</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #mediaPlayer {
            width: 100%;
            max-width: 640px;
            display: block;
            margin-bottom: 1em;
        }
        .current {
            background-color: #f0f0f0;
        }
        #audioControls {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            max-width: 640px;
        }
        .control-group {
            margin-bottom: 15px;
            padding: 5px;
            border-top: 1px solid #eee;
        }
        .control-group h4 {
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .control-group label {
            display: inline-block;
            width: 120px; /* ãƒ©ãƒ™ãƒ«å¹…ã‚’åºƒã’ã¦è¦‹ã‚„ã™ã */
            text-align: right;
            margin-right: 10px;
            font-size: small;
        }
        .control-group input[type="range"] {
            width: calc(100% - 150px);
            min-width: 150px;
        }
        /* ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #analyzerCanvas {
            display: block;
            background: #222;
            border: 1px solid #ccc;
            margin-bottom: 15px;
            width: 100%; 
            max-width: 640px; 
            height: auto;
        }
    </style>
</head>
<body>
    <input type="file" multiple id="fileInput" accept=".mp3,.wav,.ogg,.m4a,.aac,.flac,.aiff"><br>
    
    <div id="playerContainer"></div>
    <p id="songInfo"></p>

    <canvas id="analyzerCanvas" width="640" height="150"></canvas>
    
    <div id="audioControls">
        <h3>ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š</h3>

        <div id="masterControls" class="control-group">
            <h4>ãƒã‚¹ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h4>
            <label for="masterGain">éŸ³é‡ (Gain):</label>
            <input type="range" id="masterGain" min="0" max="2" value="1" step="0.01">
            <span id="masterGainValue">1.00</span> (xå€)<br>

            <label for="playbackRate">å†ç”Ÿé€Ÿåº¦:</label>
            <input type="range" id="playbackRate" min="0.5" max="2.0" value="1.0" step="0.01">
            <span id="playbackRateValue">1.00</span> (xå€é€Ÿ)<br>
            
            <label for="pitchShift">ãƒ”ãƒƒãƒ (åŠéŸ³):</label>
            <input type="range" id="pitchShift" min="-12" max="12" value="0" step="1">
            <span id="pitchShiftValue">0</span> (åŠéŸ³)
            <br>


            <label for="panner">å®šä½ (Pan):</label>
            <input type="range" id="panner" min="-1" max="1" value="0" step="0.01">
            <span id="pannerValue">0.00</span> (å·¦-1.0ã€œå³1.0)
        </div>

        <div id="compressorControl" class="control-group">
            <h4>ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ (éŸ³åœ§èª¿æ•´)</h4>
            <label for="compThreshold">Threshold (dB):</label>
            <input type="range" id="compThreshold" min="-60" max="0" value="-24" step="0.1">
            <span id="compThresholdValue">-24.0</span><br>
            <label for="compRatio">Ratio:</label>
            <input type="range" id="compRatio" min="1" max="20" value="4" step="0.1">
            <span id="compRatioValue">4.0</span>
        </div>

        <div id="distortionControl" class="control-group">
            <h4>ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³ (æ­ªã¿)</h4>
            <label for="distortionAmount">æ­ªã¿é‡:</label>
            <input type="range" id="distortionAmount" min="0" max="100" value="0" step="1">
            <span id="distortionAmountValue">0</span> (%)
        </div>

        <div id="equalizer" class="control-group">
            <h4>ã‚¤ã‚³ãƒ©ã‚¤ã‚¶ãƒ¼ (dB)</h4>
            <div class="eq-band"><label for="eq60">60Hz:</label><input type="range" id="eq60" min="-12" max="12" value="0" step="0.1"><span class="gain-value">0.0</span></div>
            <div class="eq-band"><label for="eq250">250Hz:</label><input type="range" id="eq250" min="-12" max="12" value="0" step="0.1"><span class="gain-value">0.0</span></div>
            <div class="eq-band"><label for="eq1k">1kHz:</label><input type="range" id="eq1k" min="-12" max="12" value="0" step="0.1"><span class="gain-value">0.0</span></div>
            <div class="eq-band"><label for="eq4k">4kHz:</label><input type="range" id="eq4k" min="-12" max="12" value="0" step="0.1"><span class="gain-value">0.0</span></div>
            <div class="eq-band"><label for="eq16k">16kHz:</label><input type="range" id="eq16k" min="-12" max="12" value="0" step="0.1"><span class="gain-value">0.0</span></div>
        </div>
        
        <div id="reverbControl" class="control-group">
            <h4>ãƒªãƒãƒ¼ãƒ–ï¼ˆæ®‹éŸ¿ï¼‰</h4>
            <label for="reverbPreset">ãƒ—ãƒªã‚»ãƒƒãƒˆ:</label>
            <select id="reverbPreset">
                <option value="0">ã‚ªãƒ•</option>
                <option value="0.3" selected>å°éƒ¨å±‹</option>
                <option value="0.6">ä¸­è¦æ¨¡ãƒ›ãƒ¼ãƒ«</option>
                <option value="0.9">å¤§è–å ‚</option>
                <option value="1.2">è¶…ç‰¹å¤§</option>
            </select><br>
            
            <label for="reverbMix">æ®‹éŸ¿ã®æ·±ã•:</label>
            <input type="range" id="reverbMix" min="0" max="1.5" value="0.3" step="0.01">
            <span id="reverbMixValue">0.30</span>
        </div>

        <div id="delayControl" class="control-group">
            <h4>ãƒ‡ã‚£ãƒ¬ã‚¤ï¼ˆã‚¨ã‚³ãƒ¼ï¼‰</h4>
            <label for="delayTime">Delay Time (ç§’):</label>
            <input type="range" id="delayTime" min="0" max="1" value="0" step="0.01">
            <span id="delayTimeValue">0.00</span><br>

            <label for="delayFeedback">Feedback:</label>
            <input type="range" id="delayFeedback" min="0" max="0.95" value="0" step="0.01">
            <span id="delayFeedbackValue">0.00</span><br>

            <label for="delayMix">Mix (ã‚¦ã‚§ãƒƒãƒˆ):</label>
            <input type="range" id="delayMix" min="0" max="1" value="0" step="0.01">
            <span id="delayMixValue">0.00</span>
        </div>

    </div>
    
    <br>
    
    <table>
        <thead>
            <tr>
                <th>ğŸµ</th>
                <th>ãƒ¡ãƒ‡ã‚£ã‚¢å</th>
                <th>é•·ã•</th>
            </tr>
        </thead>
        <tbody id="playHistoryTable"></tbody>
    </table>
    
    <button id="prevButton">å‰ã®ãƒ¡ãƒ‡ã‚£ã‚¢</button>
    <button id="nextButton">æ¬¡ã®ãƒ¡ãƒ‡ã‚£ã‚¢</button>
    <button id="sleepTimerButton">ã‚¿ã‚¤ãƒãƒ¼: ã‚ªãƒ•</button>

<script>
// ====================================================================
// DOMè¦ç´ ã®å–å¾—ã¨å®šæ•°
// ====================================================================

const fileInput = document.getElementById("fileInput");
const playerContainer = document.getElementById("playerContainer");
const songInfo = document.getElementById("songInfo");
const playHistoryTable = document.getElementById("playHistoryTable");
const prevButton = document.getElementById("prevButton");
const nextButton = document.getElementById("nextButton");

// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
const playbackRateInput = document.getElementById('playbackRate');
const playbackRateValueSpan = document.getElementById('playbackRateValue');
const masterGainInput = document.getElementById('masterGain');
const masterGainValueSpan = document.getElementById('masterGainValue');
const pannerInput = document.getElementById('panner');
const pannerValueSpan = document.getElementById('pannerValue');
const pitchShiftInput = document.getElementById('pitchShift');
const pitchShiftValueSpan = document.getElementById('pitchShiftValue');

// EQ
const eqBands = [
    { freq: 60, input: document.getElementById('eq60') },
    { freq: 250, input: document.getElementById('eq250') },
    { freq: 1000, input: document.getElementById('eq1k') },
    { freq: 4000, input: document.getElementById('eq4k') },
    { freq: 16000, input: document.getElementById('eq16k') }
];

// Reverb
const reverbPreset = document.getElementById('reverbPreset');
const reverbMixInput = document.getElementById('reverbMix');
const reverbMixValueSpan = document.getElementById('reverbMixValue');

// Delay
const delayTimeInput = document.getElementById('delayTime');
const delayTimeValueSpan = document.getElementById('delayTimeValue');
const delayFeedbackInput = document.getElementById('delayFeedback');
const delayFeedbackValueSpan = document.getElementById('delayFeedbackValue');
const delayMixInput = document.getElementById('delayMix');
const delayMixValueSpan = document.getElementById('delayMixValue');

// Distortion
const distortionAmountInput = document.getElementById('distortionAmount');
const distortionAmountValueSpan = document.getElementById('distortionAmountValue');

// Compressor
const compThresholdInput = document.getElementById('compThreshold');
const compThresholdValueSpan = document.getElementById('compThresholdValue');
const compRatioInput = document.getElementById('compRatio');
const compRatioValueSpan = document.getElementById('compRatioValue');

// ã‚¢ãƒŠãƒ©ã‚¤ã‚¶
const canvas = document.getElementById('analyzerCanvas');
const canvasCtx = canvas.getContext('2d');


let playlist = []; 
let currentTrackIndex = 0;
let currentPlayer = null;

let audioContext = null;
let sourceNode = null;

// --- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒãƒ¼ãƒ‰ç¾¤ï¼ˆå®£è¨€ã‚’ã“ã“ã§ã¾ã¨ã‚ã¦è¡Œã†ï¼‰ ---
let masterGainNode = null; 
let stereoPannerNode = null;
let dynamicsCompressorNode = null;

let tonePlayer = null;
let pitchShiftNode = null;

let distortionNode = null;
let eqNodes = [];

let reverbBuffer = null;
let convolverNode = null;  
let reverbDryGainNode = null;    
let reverbWetGainNode = null;    

let delayNode = null;
let delayFeedbackGain = null;
let delayDryGainNode = null;
let delayWetGainNode = null;

// ã“ã“ãŒå•é¡Œã ã£ãŸï¼šanalyzerNode ã‚’å®£è¨€ã—ã¦ã„ãªã‹ã£ãŸãŸã‚ ReferenceError ãŒå‡ºã¦ã„ãŸ
let analyzerNode = null;

// ====================================================================
// Web Audio API ãƒãƒ¼ãƒ‰ã®åˆæœŸåŒ–ã¨ã‚°ãƒ©ãƒ•æ¥ç¶š
// ====================================================================

// ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚«ãƒ¼ãƒ–ç”Ÿæˆé–¢æ•°
function makeDistortionCurve(amount) {
    const k = amount * 10;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    
    for (let i = 0; i < n_samples; ++i) {
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
}

// ãƒªãƒãƒ¼ãƒ–ç”¨ã®ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹å¿œç­”ç”Ÿæˆé–¢æ•° (ã‚·ãƒ³ãƒ—ãƒ«ç‰ˆ)
function createReverbBuffer(context, duration = 0.5) {
    const sampleRate = context.sampleRate;
    const length = sampleRate * duration;
    const buffer = context.createBuffer(2, length, sampleRate);

    for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
        const data = buffer.getChannelData(channel);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
        }
    }
    return buffer;
}


function setupAudioContext() {
    if (!audioContext || !currentPlayer || !currentPlayer.src) return; 

    // æ—¢å­˜ã®æ¥ç¶šã‚’ã™ã¹ã¦è§£é™¤
    try {
        if (sourceNode) sourceNode.disconnect();
    } catch (e) { /* ignore */ }
    eqNodes.forEach(node => {
        try { node.disconnect(); } catch (e) {}
    });
    
    // --- ãƒãƒ¼ãƒ‰ã®ä½œæˆã¨åˆæœŸåŒ– ---
    
    if (!masterGainNode) masterGainNode = audioContext.createGain();
    if (!stereoPannerNode) stereoPannerNode = audioContext.createStereoPanner();
    if (!dynamicsCompressorNode) dynamicsCompressorNode = audioContext.createDynamicsCompressor();
    if (!distortionNode) distortionNode = audioContext.createWaveShaper();

    // ãƒªãƒãƒ¼ãƒ–ãƒãƒ¼ãƒ‰
    if (!convolverNode) {
        convolverNode = audioContext.createConvolver();
        reverbBuffer = createReverbBuffer(audioContext);
        convolverNode.buffer = reverbBuffer;
    }
    if (!reverbDryGainNode) reverbDryGainNode = audioContext.createGain();
    if (!reverbWetGainNode) reverbWetGainNode = audioContext.createGain();
    
    // ãƒ‡ã‚£ãƒ¬ã‚¤ãƒãƒ¼ãƒ‰ (ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã¨ãƒ‰ãƒ©ã‚¤/ã‚¦ã‚§ãƒƒãƒˆæ§‹æˆ)
    if (!delayNode) delayNode = audioContext.createDelay(1.0); // æœ€å¤§1ç§’ãƒ‡ã‚£ãƒ¬ã‚¤
    if (!delayFeedbackGain) delayFeedbackGain = audioContext.createGain();
    if (!delayDryGainNode) delayDryGainNode = audioContext.createGain();
    if (!delayWetGainNode) delayWetGainNode = audioContext.createGain();

    // AnalyserNode
    if (!analyzerNode) {
        analyzerNode = audioContext.createAnalyser();
        analyzerNode.fftSize = 2048; 
        const bufferLength = analyzerNode.frequencyBinCount;
        analyzerNode.dataArray = new Uint8Array(bufferLength);
    }
    
    // ã‚½ãƒ¼ã‚¹ï¼ˆMediaElementSourceï¼‰
    try {
        sourceNode = audioContext.createMediaElementSource(currentPlayer);
    } catch (e) {
        // æ—¢ã« currentPlayer ã«å¯¾ã—ã¦ source ä½œæˆæ¸ˆã¿ã®ã‚±ãƒ¼ã‚¹ãªã©ã®å®‰å…¨å¯¾ç­–
        console.warn("createMediaElementSource error:", e);
    }
    
    // --- ä¿¡å·ãƒ•ãƒ­ãƒ¼ã®æ¥ç¶š ---
    
    // 1. ã‚½ãƒ¼ã‚¹ -> ãƒã‚¹ã‚¿ãƒ¼ã‚²ã‚¤ãƒ³
    if (sourceNode) sourceNode.connect(masterGainNode);
    let previousNode = masterGainNode;

    // 2. ãƒã‚¹ã‚¿ãƒ¼ã‚²ã‚¤ãƒ³ -> ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³
    previousNode.connect(distortionNode);
    previousNode = distortionNode;

    // 3. ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³ -> EQç¾¤
    eqNodes = [];
    let eqInputNode = previousNode; 
    eqBands.forEach(band => {
        const filter = audioContext.createBiquadFilter();
        filter.type = 'peaking'; 
        filter.frequency.setValueAtTime(band.freq, audioContext.currentTime);
        filter.Q.setValueAtTime(1.0, audioContext.currentTime); 
        filter.gain.setValueAtTime(parseFloat(band.input.value || 0), audioContext.currentTime);
        eqNodes.push(filter);
        eqInputNode.connect(filter);
        eqInputNode = filter;
    });
    previousNode = eqInputNode; // EQã®æœ€å¾Œã®ãƒãƒ¼ãƒ‰

    // 4. EQã®å‡ºåŠ›ã‹ã‚‰3ã¤ã«åˆ†å² (ãƒ‰ãƒ©ã‚¤éŸ³ã€ãƒªãƒãƒ¼ãƒ–ã€ãƒ‡ã‚£ãƒ¬ã‚¤)

    // a) ãƒªãƒãƒ¼ãƒ– (ãƒ‘ãƒ©ãƒ¬ãƒ«æ¥ç¶š)
    previousNode.connect(convolverNode);
    convolverNode.connect(reverbWetGainNode);
    // --- é‡è¦: ãƒªãƒãƒ¼ãƒ–ã®ãƒ‰ãƒ©ã‚¤çµŒè·¯ã‚‚æ˜ç¢ºã«ä½œã‚‹ï¼ˆå…ƒéŸ³ã‚’åˆ¥ã‚²ã‚¤ãƒ³ã§ä¿æŒï¼‰ ---
    previousNode.connect(reverbDryGainNode);

    // b) ãƒ‡ã‚£ãƒ¬ã‚¤ (ãƒ‘ãƒ©ãƒ¬ãƒ«æ¥ç¶š & ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—)
    previousNode.connect(delayDryGainNode); // ãƒ‡ã‚£ãƒ¬ã‚¤ã®ãƒ‰ãƒ©ã‚¤éŸ³
    previousNode.connect(delayNode);       // ãƒ‡ã‚£ãƒ¬ã‚¤ã®ã‚¤ãƒ³ãƒ—ãƒƒãƒˆ
    
    // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—: Delay -> FeedbackGain -> Delay
    delayNode.connect(delayFeedbackGain);
    delayFeedbackGain.connect(delayNode);
    
    // ãƒ‡ã‚£ãƒ¬ã‚¤ã®å‡ºåŠ› (ã‚¦ã‚§ãƒƒãƒˆéŸ³)
    delayNode.connect(delayWetGainNode);

    // c) ãƒ‰ãƒ©ã‚¤éŸ³ (EQå¾Œã®ã‚¯ãƒªãƒ¼ãƒ³ãªéŸ³)
    // (EQå‡ºåŠ›ã¯ç›´æ¥ reverbDryGainNode / delayDryGainNode ãªã©ã«ç¹‹ãŒã‚Œã¦ã„ã‚‹æ§‹æˆ)

    // 5. ã™ã¹ã¦ã®ã‚¦ã‚§ãƒƒãƒˆ/ãƒ‰ãƒ©ã‚¤éŸ³ã‚’åˆæµã•ã›ã‚‹ãŸã‚ã®ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ (ã“ã“ã§ã¯ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ã®å‰ã«æ¥ç¶š)
    // å„ã‚¦ã‚§ãƒƒãƒˆ/ãƒ‰ãƒ©ã‚¤ã‚’ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ã¸æ¥ç¶š
    // 1. EQå¾Œã®ãƒ‰ãƒ©ã‚¤éŸ³ (reverbDryGainNode ã‹ç›´æ¥ previousNode ã®ã©ã¡ã‚‰ã‹) -> ã“ã“ã§ã¯ reverbDryGainNode ã‚’ä½¿ã†
    reverbDryGainNode.connect(analyzerNode); 
    // 2. ãƒªãƒãƒ¼ãƒ–ã®ã‚¦ã‚§ãƒƒãƒˆéŸ³
    reverbWetGainNode.connect(analyzerNode); 
    // 3. ãƒ‡ã‚£ãƒ¬ã‚¤ã®ãƒ‰ãƒ©ã‚¤éŸ³
    delayDryGainNode.connect(analyzerNode);
    // 4. ãƒ‡ã‚£ãƒ¬ã‚¤ã®ã‚¦ã‚§ãƒƒãƒˆéŸ³
    delayWetGainNode.connect(analyzerNode);

    // 6. ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ -> ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ -> ãƒ‘ãƒ³ãƒŠãƒ¼ -> æœ€çµ‚å‡ºåŠ›
    analyzerNode.connect(dynamicsCompressorNode);
    dynamicsCompressorNode.connect(stereoPannerNode);
    stereoPannerNode.connect(audioContext.destination);
    
    // --- åˆæœŸå€¤ã®é©ç”¨ ---
    
    updateDistortionCurve(parseFloat(distortionAmountInput.value));
    updateReverbMix(parseFloat(reverbMixInput.value));
    updateDelayControls();
    updateCompressorControls();
    updatePanner();

    masterGainNode.gain.setValueAtTime(parseFloat(masterGainInput.value), audioContext.currentTime);
    
    // EQã®åˆæœŸå€¤ã‚’è¨­å®šï¼ˆç”»é¢ã®ã‚¹ãƒ©ã‚¤ãƒ€å€¤ã‚’åæ˜ ï¼‰
    eqBands.forEach(({ input }, index) => {
        if (eqNodes[index]) eqNodes[index].gain.setValueAtTime(parseFloat(input.value), audioContext.currentTime);
    });

    // ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ã®æç”»ã‚’é–‹å§‹
    drawAnalyzer();

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¡¨ç¤ºã‚’æ›´æ–°
    masterGainValueSpan.textContent = parseFloat(masterGainInput.value).toFixed(2);
    playbackRateValueSpan.textContent = parseFloat(playbackRateInput.value).toFixed(2);
    pannerValueSpan.textContent = parseFloat(pannerInput.value).toFixed(2);
    reverbMixValueSpan.textContent = parseFloat(reverbMixInput.value).toFixed(2);
    delayTimeValueSpan.textContent = parseFloat(delayTimeInput.value).toFixed(2);
    delayFeedbackValueSpan.textContent = parseFloat(delayFeedbackInput.value).toFixed(2);
    delayMixValueSpan.textContent = parseFloat(delayMixInput.value).toFixed(2);
    distortionAmountValueSpan.textContent = parseFloat(distortionAmountInput.value);
    compThresholdValueSpan.textContent = parseFloat(compThresholdInput.value).toFixed(1);
    compRatioValueSpan.textContent = parseFloat(compRatioInput.value).toFixed(1);
    eqBands.forEach(({ input }) => {
        input.nextElementSibling.textContent = parseFloat(input.value).toFixed(1);
    });
}


    async function setupAudioContext() {
    if (!audioContext || !currentPlayer || !currentPlayer.src) return;

    // AudioContext ã®ç”Ÿæˆ
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Tone.js ã® AudioContext ã‚’æ—¢å­˜ã«åŒæœŸ
    await Tone.setContext(audioContext);

    // æ—¢å­˜ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢
    if (tonePlayer) {
        tonePlayer.dispose();
        pitchShiftNode.dispose();
    }

    // Tone.js Player ã‚’å†ç”Ÿæˆ
    tonePlayer = new Tone.Player({
        url: currentPlayer.src,
        autostart: false,
        loop: false
    }).toDestination();

    // PitchShift ãƒãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆåŠéŸ³å˜ä½æŒ‡å®šï¼‰
    pitchShiftNode = new Tone.PitchShift(0); // 0 = åŠéŸ³å¤‰åŒ–ãªã—

    // Tone Player â†’ PitchShift â†’ AudioContextå…¥åŠ›ãƒã‚§ãƒ¼ãƒ³ã«æ¥ç¶š
    tonePlayer.connect(pitchShiftNode);
    const destination = audioContext.createMediaStreamDestination();
    pitchShiftNode.connect(destination);

    // Tone.Player ã‚’ AudioContext çµŒç”±ã§æ—¢å­˜ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«æµã™
    const toneStream = destination.stream;
    const toneSource = audioContext.createMediaStreamSource(toneStream);
    sourceNode = toneSource; // æ—¢å­˜ã‚°ãƒ©ãƒ•ã®å…¥å£ã‚’Toneã‹ã‚‰ã®å‡ºåŠ›ã«å¤‰æ›´
}


// ====================================================================
// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®æ›´æ–°é–¢æ•°
// ====================================================================

function updateDistortionCurve(amount) {
    if (distortionNode) {
        if (amount > 0) {
            distortionNode.curve = makeDistortionCurve(amount);
            distortionNode.oversample = '4x';
        } else {
            distortionNode.curve = null;
        }
    }
}
function updatePitchShift(semitones) {
    if (pitchShiftNode) {
        pitchShiftNode.pitch = semitones; // åŠéŸ³å˜ä½ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¤‰æ›´
    }
}

function updateReverbMix(mixValue) {
    if (!reverbWetGainNode || !reverbDryGainNode || !audioContext) {
        return;
    }
    
    const rampTime = 0.05; 
    // ãƒ‰ãƒ©ã‚¤ã‚’ (1 - mix)ã€ã‚¦ã‚§ãƒƒãƒˆã‚’ mix ã«è¨­å®šï¼ˆç›´æ„Ÿçš„ãª Dry/Wetï¼‰
    reverbWetGainNode.gain.linearRampToValueAtTime(mixValue, audioContext.currentTime + rampTime);
    reverbDryGainNode.gain.linearRampToValueAtTime(Math.max(0, 1 - mixValue), audioContext.currentTime + rampTime);
}

function updateDelayControls() {
    if (!delayNode || !delayFeedbackGain || !delayWetGainNode || !delayDryGainNode || !audioContext) {
        return;
    }
    const time = parseFloat(delayTimeInput.value);
    const feedback = parseFloat(delayFeedbackInput.value);
    const mix = parseFloat(delayMixInput.value);
    const rampTime = 0.05; 

    delayNode.delayTime.linearRampToValueAtTime(time, audioContext.currentTime + rampTime);
    delayFeedbackGain.gain.linearRampToValueAtTime(feedback, audioContext.currentTime + rampTime);
    
    // Wet/Dry ã®èª¿æ•´
    delayWetGainNode.gain.linearRampToValueAtTime(mix, audioContext.currentTime + rampTime);
    delayDryGainNode.gain.linearRampToValueAtTime(Math.max(0, 1 - mix), audioContext.currentTime + rampTime);
}

function updateCompressorControls() {
    if (!dynamicsCompressorNode || !audioContext) return;
    
    const threshold = parseFloat(compThresholdInput.value);
    const ratio = parseFloat(compRatioInput.value);

    dynamicsCompressorNode.threshold.setValueAtTime(threshold, audioContext.currentTime);
    dynamicsCompressorNode.ratio.setValueAtTime(ratio, audioContext.currentTime);
}

function updatePanner() {
    if (!stereoPannerNode || !audioContext) return;
    
    const pan = parseFloat(pannerInput.value);
    stereoPannerNode.pan.setValueAtTime(pan, audioContext.currentTime);
}

// ====================================================================
// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
// ====================================================================

masterGainInput.addEventListener('input', () => {
    const gainValue = parseFloat(masterGainInput.value);
    masterGainValueSpan.textContent = gainValue.toFixed(2);
    if (masterGainNode && audioContext) {
        masterGainNode.gain.setValueAtTime(gainValue, audioContext.currentTime);
    }
});
pitchShiftInput.addEventListener('input', () => {
    const semitone = parseInt(pitchShiftInput.value);
    pitchShiftValueSpan.textContent = semitone;
    updatePitchShift(semitone);
});

playbackRateInput.addEventListener('input', () => {
    const rate = parseFloat(playbackRateInput.value);
    playbackRateValueSpan.textContent = rate.toFixed(2);
    if (currentPlayer) {
        currentPlayer.playbackRate = rate;
    }
});

pannerInput.addEventListener('input', () => {
    const pan = parseFloat(pannerInput.value);
    pannerValueSpan.textContent = pan.toFixed(2);
    updatePanner();
});

distortionAmountInput.addEventListener('input', () => {
    const amount = parseInt(distortionAmountInput.value);
    distortionAmountValueSpan.textContent = amount;
    updateDistortionCurve(amount);
});

compThresholdInput.addEventListener('input', () => {
    const value = parseFloat(compThresholdInput.value);
    compThresholdValueSpan.textContent = value.toFixed(1);
    updateCompressorControls();
});

compRatioInput.addEventListener('input', () => {
    const value = parseFloat(compRatioInput.value);
    compRatioValueSpan.textContent = value.toFixed(1);
    updateCompressorControls();
});


eqBands.forEach(({ freq, input }, index) => {
    input.addEventListener('input', () => {
        const gainValue = parseFloat(input.value);
        input.nextElementSibling.textContent = gainValue.toFixed(1);
        if (eqNodes[index] && audioContext) {
            eqNodes[index].gain.setValueAtTime(gainValue, audioContext.currentTime);
        }
    });
});

reverbMixInput.addEventListener('input', () => {
    const mixValue = parseFloat(reverbMixInput.value);
    reverbMixValueSpan.textContent = mixValue.toFixed(2);
    updateReverbMix(mixValue);
});

reverbPreset.addEventListener('change', () => {
    const presetValue = parseFloat(reverbPreset.value);
    reverbMixInput.value = presetValue;
    reverbMixValueSpan.textContent = presetValue.toFixed(2);
    updateReverbMix(presetValue);
});

delayTimeInput.addEventListener('input', () => {
    const time = parseFloat(delayTimeInput.value);
    delayTimeValueSpan.textContent = time.toFixed(2);
    updateDelayControls();
});
delayFeedbackInput.addEventListener('input', () => {
    const feedback = parseFloat(delayFeedbackInput.value);
    delayFeedbackValueSpan.textContent = feedback.toFixed(2);
    updateDelayControls();
});
delayMixInput.addEventListener('input', () => {
    const mix = parseFloat(delayMixInput.value);
    delayMixValueSpan.textContent = mix.toFixed(2);
    updateDelayControls();
});

// ====================================================================
// ã‚¢ãƒŠãƒ©ã‚¤ã‚¶æç”»ãƒ­ã‚¸ãƒƒã‚¯
// ====================================================================

function drawAnalyzer() {
    requestAnimationFrame(drawAnalyzer);

    if (!analyzerNode || !audioContext || audioContext.state !== 'running') {
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        return;
    }

    const WIDTH = canvas.clientWidth;
    const HEIGHT = canvas.clientHeight;
    
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    analyzerNode.getByteFrequencyData(analyzerNode.dataArray); 

    canvasCtx.fillStyle = 'rgb(34, 34, 34)'; 
    canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

    const bufferLength = analyzerNode.frequencyBinCount;
    const barWidth = (WIDTH / bufferLength) * 2.5; 
    let barHeight;
    let x = 0;

    for(let i = 0; i < bufferLength; i++) {
        barHeight = analyzerNode.dataArray[i] / 255 * HEIGHT; 

        const hue = i / bufferLength * 360 * 2;
        canvasCtx.fillStyle = 'hsl(' + hue + ', 100%, 50%)';
        
        canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);

        x += barWidth + 1;
    }
}

// ====================================================================
// ãƒ¡ãƒ‡ã‚£ã‚¢å†ç”Ÿãƒ­ã‚¸ãƒƒã‚¯
// ====================================================================

function playMediaAutomatically() {
    if (!currentPlayer) return;

    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        reverbBuffer = createReverbBuffer(audioContext);
        setupAudioContext(); 
    }

    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            currentPlayer.play().catch(e => console.error("Auto play failed after context resume:", e));
        }).catch(e => {
            console.warn("AudioContext resume failed. Waiting for user interaction to start sound.", e);
        });
    } else {
        currentPlayer.play().catch(e => console.error("Auto play failed:", e));
    }
}

// --- ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã¨ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ ---

fileInput.addEventListener("change", () => {
    const files = [...fileInput.files];
    files.forEach(file => addToPlaylist(file));
    fileInput.value = "";
});

function addToPlaylist(file) {
    const url = URL.createObjectURL(file);
    const tempEl = document.createElement("audio");
    tempEl.preload = "metadata";
    tempEl.src = url;

    tempEl.addEventListener("loadedmetadata", async () => {
        const duration = tempEl.duration;
        playlist.push({ file, url, duration, isVideo: false, thumbnail: null });

        if (playlist.length === 1 && !currentPlayer) {
            playTrack(0);
        } else {
            updatePlayHistory();
        }

        tempEl.remove();
    });
}

function playTrack(index) {
    if (!playlist[index]) return;
    const { file, url, duration } = playlist[index];
    currentTrackIndex = index;

    if (currentPlayer) {
        currentPlayer.pause();
        currentPlayer.remove();
        if (sourceNode) sourceNode.disconnect();
    }

    // é€šå¸¸ã® <audio> UI ã¯æ®‹ã™
    currentPlayer = document.createElement("audio");
    currentPlayer.id = "mediaPlayer";
    currentPlayer.controls = true;
    currentPlayer.src = url;
    currentPlayer.addEventListener("ended", playNextTrack);
    playerContainer.innerHTML = "";
    playerContainer.appendChild(currentPlayer);

    songInfo.textContent = `å†ç”Ÿä¸­: ${file.name} (${getFormattedDuration(duration)})`;
    updatePlayHistory();

    currentPlayer.addEventListener('canplay', async () => {
        await setupAudioContext();
        await Tone.loaded();

        tonePlayer.start(); // ToneçµŒç”±ã§å†ç”Ÿ
    }, { once: true });
}


// --- ãã®ä»–ã®æ©Ÿèƒ½ ---

function playNextTrack() {
    if (!playlist.length) return;
    const nextIndex = (currentTrackIndex + 1) % playlist.length;
    playTrack(nextIndex);
}

function playPrevTrack() {
    if (!playlist.length) return;
    const prevIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
    playTrack(prevIndex);
}

prevButton.addEventListener("click", playPrevTrack);
nextButton.addEventListener("click", playNextTrack);

function updatePlayHistory() {
    playHistoryTable.innerHTML = "";
    playlist.forEach((track, i) => {
        const row = playHistoryTable.insertRow();
        if (i === currentTrackIndex) row.classList.add("current");

        const thumbCell = row.insertCell();
        const nameCell = row.insertCell();
        const durCell = row.insertCell();

        thumbCell.textContent = "ğŸµ";

        nameCell.textContent = track.file.name;
        durCell.textContent = getFormattedDuration(track.duration);

        row.addEventListener("click", () => playTrack(i));
    });
}

function getFormattedDuration(seconds) {
    if (!isFinite(seconds)) return "--:--";
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${s < 10 ? "0" : ""}${s}`;
}
    
const sleepTimerButton = document.getElementById("sleepTimerButton");
const timerOptions = [5, 10, 15, 30, 60, 120, 0];
let timerIndex = 0;
let sleepTimeout = null;
let fadeOutInterval = null;

sleepTimerButton.addEventListener("click", () => {
    timerIndex = (timerIndex + 1) % timerOptions.length;
    const minutes = timerOptions[timerIndex];
    setSleepTimer(minutes);
});

function setSleepTimer(minutes) {
    if (sleepTimeout) {
        clearTimeout(sleepTimeout);
        sleepTimeout = null;
    }
    if (fadeOutInterval) {
        clearInterval(fadeOutInterval);
        fadeOutInterval = null;
    }

    if (minutes === 0) {
        sleepTimerButton.textContent = "ã‚¿ã‚¤ãƒãƒ¼: ã‚ªãƒ•";
        return;
    }

    sleepTimerButton.textContent = `ã‚¿ã‚¤ãƒãƒ¼: ${minutes}åˆ†`;

    sleepTimeout = setTimeout(() => {
        startFadeOutAndStop();
    }, minutes * 60 * 1000);
}

function startFadeOutAndStop() {
    if (!currentPlayer) return;

    let duration = 30;
    let steps = 30;
    let stepCount = 0;
    
    let initialVolume = masterGainNode ? masterGainNode.gain.value : currentPlayer.volume;

    fadeOutInterval = setInterval(() => {
        stepCount++;
        const currentGain = Math.max(0, initialVolume * (1 - stepCount / steps));

        if (masterGainNode && audioContext) {
            masterGainNode.gain.setValueAtTime(currentGain, audioContext.currentTime);
        } else {
            currentPlayer.volume = currentGain;
        }

        if (stepCount >= steps) {
            clearInterval(fadeOutInterval);
            currentPlayer.pause();
            currentPlayer.currentTime = 0;
            sleepTimerButton.textContent = "ã‚¿ã‚¤ãƒãƒ¼: ã‚ªãƒ•";
            
            if (masterGainNode && audioContext) {
                masterGainNode.gain.setValueAtTime(parseFloat(masterGainInput.value), audioContext.currentTime);
            }
        }
    }, duration * 1000 / steps);
}

</script>
</body>
</html>
