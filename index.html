<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN (Web Audio Framework) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Interãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* iOSã§ã®ã‚ªãƒ¼ãƒãƒ¼ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«ã‚ˆã‚‹ãƒã‚¦ãƒ³ã‚¹ã‚’é˜²ã */
            overscroll-behavior: none;
        }
        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¦‹ãŸç›®ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ ãƒˆãƒ©ãƒƒã‚¯ (Chrome, Safari, Edge) */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #e5e7eb; /* gray-200 */
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ ã¤ã¾ã¿ (Chrome, Safari, Edge) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -4px; /* ãƒˆãƒ©ãƒƒã‚¯ã®ä¸­å¤®ã«é…ç½® */
            background-color: #3b82f6; /* blue-500 */
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            border: 2px solid white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ ãƒˆãƒ©ãƒƒã‚¯ (Firefox) */
        input[type="range"]::-moz-range-track {
            background: #e5e7eb; /* gray-200 */
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ ã¤ã¾ã¿ (Firefox) */
        input[type="range"]::-moz-range-thumb {
            background-color: #3b82f6; /* blue-500 */
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            border: 2px solid white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        /* EQã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ (ç¸¦) */
        .vertical-slider-container {
            writing-mode: bt-lr; /* IE/Edge */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 2rem;
            height: 120px;
            padding: 0;
        }
        .vertical-slider-container input[type="range"] {
            width: 120px;
            height: 2rem;
            margin: 0;
            transform-origin: 70px 70px; /* å›è»¢ã®ä¸­å¿ƒã‚’èª¿æ•´ */
            transform: rotate(-90deg);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-8 space-y-6">
        
        <h1 class="text-3xl font-bold text-center text-blue-600">Audio FX Player</h1>
        
        <!-- 1. ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› -->
        <div class="border-b pb-6">
            <label for="file-input" class="block text-sm font-medium text-gray-700 mb-2">1. éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
            <input id="file-input" type="file" class="block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-50 file:text-blue-700
                hover:file:bg-blue-100
                cursor-pointer
            ">
            <p id="loading-status" class="text-sm text-blue-600 mt-2"></p>
        </div>

        <!-- 2. å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 border-b pb-6">
            <button id="play-pause-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                å†ç”Ÿ
            </button>
            <button id="stop-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                åœæ­¢
            </button>
            
            <!-- ãƒ«ãƒ¼ãƒ— -->
            <label for="loop-toggle" class="flex items-center justify-center bg-gray-100 p-3 rounded-lg shadow-inner cursor-pointer">
                <input type="checkbox" id="loop-toggle" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                <span class="ml-3 font-medium text-gray-700">ãƒ«ãƒ¼ãƒ—</span>
            </label>

            <!-- ã‚ªãƒ•ã‚¿ã‚¤ãƒãƒ¼ -->
            <div class="flex items-center space-x-2 bg-gray-100 p-3 rounded-lg shadow-inner">
                <input type="number" id="timer-input" min="1" placeholder="åˆ†" class="w-16 p-2 rounded-md border border-gray-300 text-sm focus:ring-blue-500 focus:border-blue-500">
                <button id="timer-btn" class="bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium py-2 px-3 rounded-md shadow transition duration-200">
                    ã‚¿ã‚¤ãƒãƒ¼
                </button>
            </div>
            <p id="timer-status" class="text-sm text-green-600 col-span-full text-center mt-2"></p>
        </div>

        <!-- 3. ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div class="grid md:grid-cols-3 gap-6 border-b pb-6">
            <!-- ãƒã‚¹ã‚¿ãƒ¼Gain -->
            <div class_controls>
                <label for="gain-slider" class="block text-sm font-medium text-gray-700">ãƒã‚¹ã‚¿ãƒ¼Gain (<span id="gain-value">0</span> dB)</label>
                <input id="gain-slider" type="range" min="-40" max="10" value="0" step="0.5" class="mt-2">
            </div>
            <!-- å†ç”Ÿé€Ÿåº¦ (ãƒ”ãƒƒãƒä¸å¤‰) -->
            <div class_controls>
                <label for="rate-slider" class="block text-sm font-medium text-gray-700">å†ç”Ÿé€Ÿåº¦ (<span id="rate-value">1.00</span> x)</label>
                <input id="rate-slider" type="range" min="0.5" max="2.0" value="1.0" step="0.01" class="mt-2">
            </div>
            <!-- ãƒ”ãƒƒãƒãƒ™ãƒ³ãƒ‰ (é€Ÿåº¦ä¸å¤‰) -->
            <div class_controls>
                <label for="pitch-slider" class="block text-sm font-medium text-gray-700">ãƒ”ãƒƒãƒ (<span id="pitch-value">0</span> ã‚»ãƒ³ãƒˆ)</label>
                <input id="pitch-slider" type="range" min="-1200" max="1200" value="0" step="1" class="mt-2">
            </div>
        </div>

        <!-- 4. ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ -->
        <div class="space-y-6 border-b pb-6">
            <h2 class="text-xl font-semibold text-gray-800">ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ</h2>
            
            <!-- ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ & ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³ -->
            <div class="grid md:grid-cols-2 gap-6">
                <!-- ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ -->
                <div>
                    <h3 class="font-medium text-gray-700 mb-2">ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼</h3>
                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner space-y-3">
                        <div>
                            <label for="comp-threshold" class="text-sm">Threshold (<span id="comp-threshold-value">-24</span> dB)</label>
                            <input id="comp-threshold" type="range" min="-60" max="0" value="-24" step="1">
                        </div>
                        <div>
                            <label for="comp-ratio" class="text-sm">Ratio (<span id="comp-ratio-value">12</span>:1)</label>
                            <input id="comp-ratio" type="range" min="1" max="20" value="12" step="0.5">
                        </div>
                    </div>
                </div>
                <!-- ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³ -->
                <div>
                    <h3 class="font-medium text-gray-700 mb-2">ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³</h3>
                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner space-y-3">
                        <div>
                            <label for="dist-amount" class="text-sm">Amount (<span id="dist-amount-value">0.00</span>)</label>
                            <input id="dist-amount" type="range" min="0" max="1" value="0" step="0.01">
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5ãƒãƒ³ãƒ‰ã‚¤ã‚³ãƒ©ã‚¤ã‚¶ãƒ¼ -->
            <div>
                <h3 class="font-medium text-gray-700 mb-2">5ãƒãƒ³ãƒ‰ ã‚¤ã‚³ãƒ©ã‚¤ã‚¶ãƒ¼ (dB)</h3>
                <div class="p-4 bg-gray-50 rounded-lg shadow-inner flex justify-around items-end space-x-2">
                    <!-- 60Hz -->
                    <div class="text-center">
                        <span id="eq1-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq1" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">60Hz</label>
                    </div>
                    <!-- 250Hz -->
                    <div class="text-center">
                        <span id="eq2-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq2" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">250Hz</label>
                    </div>
                    <!-- 1kHz -->
                    <div class="text-center">
                        <span id="eq3-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq3" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">1kHz</label>
                    </div>
                    <!-- 4kHz -->
                    <div class="text-center">
                        <span id="eq4-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq4" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">4kHz</label>
                    </div>
                    <!-- 10kHz -->
                    <div class="text-center">
                        <span id="eq5-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq5" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">10kHz</label>
                    </div>
                </div>
            </div>

            <!-- ãƒªãƒãƒ¼ãƒ– -->
            <div>
                <h3 class="font-medium text-gray-700 mb-2">ãƒªãƒãƒ¼ãƒ–</h3>
                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner space-y-3">
                    <div>
                        <label for="reverb-decay" class="text-sm">Decay (s) (<span id="reverb-decay-value">1.5</span>)</label>
                        <input id="reverb-decay" type="range" min="0.1" max="10" value="1.5" step="0.1">
                    </div>
                    <div>
                        <label for="reverb-wet" class="text-sm">Wet (<span id="reverb-wet-value">0.00</span>)</label>
                        <input id="reverb-wet" type="range" min="0" max="1" value="0" step="0.01">
                    </div>
                </div>
            </div>
        </div>

        <!-- 4.5.  Gemini AI ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ -->
        <div class="space-y-4 border-b pb-6">
            <h2 class="text-xl font-semibold text-gray-800"> AI ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ</h2>
            <div class="p-4 bg-gradient-to-br from-blue-50 to-purple-50 rounded-lg shadow-inner space-y-3">
                <label for="ai-prompt" class="block text-sm font-medium text-gray-700">ã©ã®ã‚ˆã†ãªã‚µã‚¦ãƒ³ãƒ‰ã«ã—ãŸã„ã§ã™ã‹ï¼Ÿ</label>
                <textarea id="ai-prompt" rows="2" class="w-full p-2 rounded-md border border-gray-300 focus:ring-blue-500 focus:border-blue-500" placeholder="ä¾‹: ãƒãƒƒãƒ‰ã‚­ãƒ£ã‚¹ãƒˆé¢¨, ãƒœãƒ¼ã‚«ãƒ«ã‚’ã‚¯ãƒªã‚¢ã«, AMãƒ©ã‚¸ã‚ªé¢¨ã®ã‚µã‚¦ãƒ³ãƒ‰"></textarea>
                <button id="ai-generate-btn" class="w-full bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-200">
                    è¨­å®šã‚’ç”Ÿæˆ
                </button>
                <div id="ai-response-area" class="mt-3 p-3 bg-white rounded-md border border-gray-200 min-h-[50px] text-sm text-gray-700">
                    <p id="ai-status" class="text-gray-500">ã“ã“ã«AIã‹ã‚‰ã®ææ¡ˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
                </div>
                <button id="ai-apply-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    è¨­å®šã‚’é©ç”¨
                </button>
            </div>
        </div>


        <!-- 5. ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ -->
        <div>
            <h2 class="text-xl font-semibold text-gray-800 mb-4">ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¢ãƒŠãƒ©ã‚¤ã‚¶</h2>
            <div class="grid md:grid-cols-2 gap-4">
                <div>
                    <h3 class="font-medium text-gray-700 mb-2 text-center">æ³¢å½¢ (Waveform)</h3>
                    <canvas id="waveform-canvas" class="w-full h-32 bg-gray-900 rounded-lg shadow-inner"></canvas>
                </div>
                <div>
                    <h3 class="font-medium text-gray-700 mb-2 text-center">å‘¨æ³¢æ•° (FFT)</h3>
                    <canvas id="fft-canvas" class="w-full h-32 bg-gray-900 rounded-lg shadow-inner"></canvas>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // DOMè¦ç´ ã®å–å¾—
        const fileInput = document.getElementById('file-input');
        const loadingStatus = document.getElementById('loading-status');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const loopToggle = document.getElementById('loop-toggle');
        const timerInput = document.getElementById('timer-input');
        const timerBtn = document.getElementById('timer-btn');
        const timerStatus = document.getElementById('timer-status');

        const gainSlider = document.getElementById('gain-slider');
        const gainValue = document.getElementById('gain-value');
        const rateSlider = document.getElementById('rate-slider');
        const rateValue = document.getElementById('rate-value');
        const pitchSlider = document.getElementById('pitch-slider');
        const pitchValue = document.getElementById('pitch-value');

        const compThreshold = document.getElementById('comp-threshold');
        const compThresholdValue = document.getElementById('comp-threshold-value');
        const compRatio = document.getElementById('comp-ratio');
        const compRatioValue = document.getElementById('comp-ratio-value');
        const distAmount = document.getElementById('dist-amount');
        const distAmountValue = document.getElementById('dist-amount-value');

        const reverbDecay = document.getElementById('reverb-decay');
        const reverbDecayValue = document.getElementById('reverb-decay-value');
        const reverbWet = document.getElementById('reverb-wet');
        const reverbWetValue = document.getElementById('reverb-wet-value');

        // â˜… ä¿®æ­£: aiKeyã‚’è¿½åŠ ã—ã€AIè¨­å®šã¨ã®å¯¾å¿œã‚’æ˜ç¢ºåŒ–
        const eqSliders = [
            { el: document.getElementById('eq1'), freq: 60, valEl: document.getElementById('eq1-value'), aiKey: 'eq1_60hz' },
            { el: document.getElementById('eq2'), freq: 250, valEl: document.getElementById('eq2-value'), aiKey: 'eq2_250hz' },
            { el: document.getElementById('eq3'), freq: 1000, valEl: document.getElementById('eq3-value'), aiKey: 'eq3_1khz' },
            { el: document.getElementById('eq4'), freq: 4000, valEl: document.getElementById('eq4-value'), aiKey: 'eq4_4khz' },
            { el: document.getElementById('eq5'), freq: 10000, valEl: document.getElementById('eq5-value'), aiKey: 'eq5_10khz' }
        ];

        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const fftCanvas = document.getElementById('fft-canvas');
        const fftCtx = fftCanvas.getContext('2d');

        // AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆDOM
        const aiPrompt = document.getElementById('ai-prompt');
        const aiGenerateBtn = document.getElementById('ai-generate-btn');
        const aiResponseArea = document.getElementById('ai-response-area');
        const aiStatus = document.getElementById('ai-status');
        const aiApplyBtn = document.getElementById('ai-apply-btn');


        // Tone.jsã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        let player, masterGain, compressor, distortion, eqFilters, reverb, analyserWave, analyserFft;
        let isPlaying = false;
        let isInitialized = false;
        let audioReady = false;
        let stopTimer = null;
        let currentAiSettings = null; // AIãŒç”Ÿæˆã—ãŸè¨­å®šã‚’ä¿æŒ

        // ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
        function setupCanvas(canvas, ctx) {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = canvas.offsetHeight;
        }

        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒ¼ãƒ‰ã®åˆæœŸåŒ–ã¨æ¥ç¶š
        function initializeAudioNodes() {
    if (isInitialized) return;

    // ãƒã‚¹ã‚¿ãƒ¼ã¯ dB å˜ä½ã§ä½œã‚‹ãŒã€æœ€çµ‚ destination ã¸ã¯ masterGain ã‚’çµŒç”±ã—ã¦æ¥ç¶šã™ã‚‹
    masterGain = new Tone.Gain({ gain: parseFloat(gainSlider.value), units: 'decibels' });
    // åˆ†æç”¨ã« Analyser ã‚’ä½œã‚‹ï¼ˆã‚¿ãƒƒãƒ—ç”¨ï¼‰
    analyserWave = new Tone.Analyser('waveform', 1024);
    analyserFft = new Tone.Analyser('fft', 256);

    // ãƒªãƒãƒ¼ãƒ–ã¯ toDestination() ã«ç›´æ¥ã¤ãªã’ãªã„ï¼ˆå¿…ãš masterGain ã‚’é€šã™ï¼‰
    reverb = new Tone.Reverb({
        decay: parseFloat(reverbDecay.value),
        // wetã¯AudioParamã£ã½ã„ã®ã§åˆæœŸå€¤ã¯ã“ã“ã«
        wet: parseFloat(reverbWet.value)
    });

    compressor = new Tone.Compressor({
        threshold: parseFloat(compThreshold.value),
        ratio: parseFloat(compRatio.value)
    });

    // 5ãƒãƒ³ãƒ‰EQ ã‚’ä½œã‚‹ï¼ˆpeakingï¼‰ã€‚gainã¯AudioParamãªã®ã§åˆæœŸå€¤ã‚’ä¸ãˆã‚‹
    eqFilters = eqSliders.map(eq => {
        return new Tone.Filter({
            type: 'peaking',
            frequency: eq.freq,
            Q: 1,
            gain: parseFloat(eq.el.value)
        });
    });

    // Distortion
    distortion = new Tone.Distortion(parseFloat(distAmount.value));

    // --- æ¥ç¶šãƒã‚§ãƒ¼ãƒ³ï¼ˆæ˜ç¢ºã« masterGain ã‚’æœ€å¾Œã«é€šã™ï¼‰ ---
    // Player -> Distortion -> Compressor -> ...eqFilters -> Reverb -> masterGain -> Destination
    distortion.connect(compressor);
    compressor.chain(...eqFilters);
    eqFilters[eqFilters.length - 1].connect(reverb);

    // reverb -> masterGain -> destination
    reverb.connect(masterGain);
    masterGain.toDestination();

    // --- ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ã¯ã€Œã‚¿ãƒƒãƒ—ã€ã§æ¥ç¶šï¼ˆãƒã‚§ãƒ¼ãƒ³ã«æŒŸã¾ãªã„ï¼‰ ---
    // å†ç”Ÿä¿¡å·ã®è¦³æ¸¬ç‚¹ã¨ã—ã¦ reverb å‡ºåŠ›ã¨ masterGain å‡ºåŠ›ã‚’ã‚¿ãƒƒãƒ—
    reverb.connect(analyserWave);     // æ³¢å½¢ã¯ãƒªãƒãƒ¼ãƒ–å¾Œã‚’è¦³æ¸¬
    masterGain.connect(analyserFft);  // FFT ã¯æœ€çµ‚å‡ºåŠ›ã‚’è¦³æ¸¬

    // Canvas ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¦æç”»ãƒ«ãƒ¼ãƒ—é–‹å§‹
    setupCanvas(waveformCanvas, waveformCtx);
    setupCanvas(fftCanvas, fftCtx);
    drawAnalysers();

    isInitialized = true;
}

        // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            loadingStatus.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
            playPauseBtn.disabled = true;
            stopBtn.disabled = true;
            audioReady = false;

            if (player) {
                player.stop();
                player.unsync(); // Transportã¨ã®åŒæœŸã‚’è§£é™¤
                player.dispose(); // å¤ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç ´æ£„
            }

            // Transportã‚’åœæ­¢ãƒ»ãƒªã‚»ãƒƒãƒˆ
            if (isInitialized) {
                Tone.Transport.stop();
                Tone.Transport.position = 0;
                isPlaying = false;
                playPauseBtn.textContent = 'å†ç”Ÿ';
            }

            const url = URL.createObjectURL(file);
            
            try {
                await Tone.start();
                initializeAudioNodes();

                player = new Tone.Player(url, () => {
                    // èª­ã¿è¾¼ã¿å®Œäº†ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    loadingStatus.textContent = `èª­ã¿è¾¼ã¿å®Œäº†: ${file.name}`;
                    playPauseBtn.disabled = false;
                    stopBtn.disabled = false;
                    audioReady = true;

                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒã‚§ãƒ¼ãƒ³ã®å…ˆé ­ã«æ¥ç¶š
                    if (distortion) {
                        player.connect(distortion);
                    } else {
                        // ç•°å¸¸ç³»: distortionãƒãƒ¼ãƒ‰ãŒãªã‘ã‚Œã°masterGainã«ç›´æ¥æ¥ç¶š
                        player.connect(masterGain);
                    }

                    // ãƒ«ãƒ¼ãƒ—æ©Ÿèƒ½ã®åˆæœŸè¨­å®šã‚’UIã«åŒæœŸã•ã›ã‚‹
                    const isLooping = loopToggle.checked;
                    player.loop = isLooping; 
                    
                    if (isInitialized) {
                        Tone.Transport.loopEnd = player.buffer.duration;
                        Tone.Transport.loopStart = 0;
                        Tone.Transport.loop = isLooping;
                    }
                    
                    // åˆæœŸãƒ”ãƒƒãƒ/ãƒ¬ãƒ¼ãƒˆè¨­å®šã®é©ç”¨
                    const initialRate = parseFloat(rateSlider.value);
                    const initialUserPitch = parseFloat(pitchSlider.value);
                    const initialCorrection = 1200 * Math.log2(1 / initialRate); 

                    player.playbackRate = initialRate;
                    player.detune = initialUserPitch + initialCorrection;

                    // Transportã«åŒæœŸã—ã¦å†ç”Ÿï¼ˆTransportã¯ã¾ã é–‹å§‹ã—ã¦ã„ãªã„ï¼‰
                    player.sync().start(0);
                });
                
                // å†ç”Ÿçµ‚äº†æ™‚ã®å‡¦ç† (Transporté€£æº)
                player.onstop = () => {
                    if (Tone.Transport.state === 'started' && !player.loop) {
                         Tone.Transport.stop();
                         Tone.Transport.position = 0;
                         isPlaying = false;
                         playPauseBtn.textContent = 'å†ç”Ÿ';
                    }
                };
                
            } catch (error) {
                loadingStatus.textContent = `ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ (${error.message})`;
                console.error("Audio Load Error:", error);
            }
        });

        // å†ç”Ÿãƒ»ä¸€æ™‚åœæ­¢
        playPauseBtn.addEventListener('click', async () => {
            if (!audioReady) return;
            await Tone.start();
            initializeAudioNodes();

            if (Tone.Transport.state === 'started') {
                Tone.Transport.pause();
                isPlaying = false;
                playPauseBtn.textContent = 'å†ç”Ÿ';
            } else {
                Tone.Transport.start();
                isPlaying = true;
                playPauseBtn.textContent = 'ä¸€æ™‚åœæ­¢';
            }
        });

        // åœæ­¢
        stopBtn.addEventListener('click', () => {
            if (!audioReady) return;
            Tone.Transport.stop();
            Tone.Transport.position = 0; 
            isPlaying = false;
            playPauseBtn.textContent = 'å†ç”Ÿ';
        });

        // ãƒ«ãƒ¼ãƒ—
        loopToggle.addEventListener('change', (e) => {
            const isLooping = e.target.checked;
            if (player) {
                player.loop = isLooping;
                if (isInitialized) {
                    Tone.Transport.loop = isLooping;
                    if (player.buffer) {
                        Tone.Transport.loopEnd = player.buffer.duration;
                    }
                }
            }
        });

        // ã‚ªãƒ•ã‚¿ã‚¤ãƒãƒ¼
        timerBtn.addEventListener('click', () => {
            if (stopTimer) {
                clearTimeout(stopTimer);
                stopTimer = null;
                timerStatus.textContent = 'ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚';
                return;
            }

            const minutes = parseInt(timerInput.value);
            if (isNaN(minutes) || minutes <= 0) {
                timerStatus.textContent = 'æœ‰åŠ¹ãªåˆ†æ•° (1åˆ†ä»¥ä¸Š) ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
                return;
            }

            const ms = minutes * 60 * 1000;
            timerStatus.textContent = `${minutes}åˆ†å¾Œã«è‡ªå‹•åœæ­¢ã—ã¾ã™ã€‚`;
            timerInput.value = '';

            stopTimer = setTimeout(() => {
                if (isPlaying) {
                    if (player) {
                        player.stop();
                    }
                    Tone.Transport.stop();
                    Tone.Transport.position = 0;
                    isPlaying = false;
                    playPauseBtn.textContent = 'å†ç”Ÿ';
                }
                timerStatus.textContent = 'ã‚¿ã‚¤ãƒãƒ¼çµ‚äº† - è‡ªå‹•åœæ­¢ã—ã¾ã—ãŸã€‚';
                stopTimer = null;
            }, ms);
        });

        // --- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ---

        // Gain
        gainSlider.addEventListener('input', (e) => {
            const db = parseFloat(e.target.value);
            gainValue.textContent = db.toFixed(1);
            if (masterGain) {
                masterGain.gain.value = db;
            }
        });

        // é€Ÿåº¦ã¨ãƒ”ãƒƒãƒã®é€£å‹•åˆ¶å¾¡ (å†ç”Ÿé€Ÿåº¦)
        rateSlider.addEventListener('input', (e) => {
            const rate = parseFloat(e.target.value);
            rateValue.textContent = rate.toFixed(2);
            if (player) {
                // 1. å†ç”Ÿé€Ÿåº¦ã®å¤‰æ›´
                player.playbackRate = rate;

                // 2. ãƒ”ãƒƒãƒè£œæ­£: é€Ÿåº¦ã‚’å¤‰ãˆã¦ã‚‚ãƒ”ãƒƒãƒã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ï¼ˆuserPitchï¼‰ã‚’ç¶­æŒã™ã‚‹
                const speedCorrection = 1200 * Math.log2(1 / rate);
                const userPitch = parseFloat(pitchSlider.value);
                player.detune = userPitch + speedCorrection;
            }
        });

        // ãƒ”ãƒƒãƒãƒ™ãƒ³ãƒ‰ (é€Ÿåº¦ä¸å¤‰)
        pitchSlider.addEventListener('input', (e) => {
            const userPitch = parseFloat(e.target.value);
            pitchValue.textContent = userPitch.toFixed(0);
            if (player) {
                const rate = parseFloat(rateSlider.value);
                const speedCorrection = 1200 * Math.log2(1 / rate);
                const detuneValue = userPitch + speedCorrection;
        
                if (player.detune && typeof player.detune === 'object' && 'value' in player.detune) {
                    player.detune.value = detuneValue;
                } else {
                    player.set({ detune: detuneValue }); // â† Tone.jsæ¨å¥¨ã®æ›¸ãæ–¹
                }
            }
        });

        // ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼
        compThreshold.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            compThresholdValue.textContent = val.toFixed(0);
            if (compressor) compressor.threshold.value = val;
        });

        compRatio.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            compRatioValue.textContent = val.toFixed(1);
            if (compressor) compressor.ratio.value = val;
        });

        // ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³
        distAmount.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            distAmountValue.textContent = val.toFixed(2);
            if (distortion) {
                // Tone.Distortion ã®å®Ÿè£…å·®ã§ property ãŒ AudioParam ã‹ number ã‹ãŒé•ã†å ´åˆãŒã‚ã‚‹ãŸã‚ä¸¡æ–¹ã«å¯¾å¿œ
                if (distortion.distortion && typeof distortion.distortion === 'object' && 'value' in distortion.distortion) {
                    distortion.distortion.value = val;
                } else {
                    try { distortion.distortion = val; } catch (err) { console.warn('Cannot set distortion.distortion directly', err); }
                }
            }
        });

        // EQ
eqSliders.forEach((eq, index) => {
    eq.el.addEventListener('input', (e) => {
        const gain = parseFloat(e.target.value);
        eq.valEl.textContent = gain.toFixed(1);
        if (eqFilters && eqFilters[index]) {
            // gain ã¯ AudioParam ã®ã¯ãšãªã®ã§ .gain.value ã‚’ä½¿ã†
            if (eqFilters[index].gain && 'value' in eqFilters[index].gain) {
                eqFilters[index].gain.value = gain;
            } else {
                // ã¾ã‚Œã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç›´æ›¸ããŒå¿…è¦ãªã‚‰ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                try { eqFilters[index].gain = gain; } catch (err) { console.warn('Cannot set filter gain directly', err); }
            }
        }
    });
});

        // ãƒªãƒãƒ¼ãƒ–
        reverbDecay.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            reverbDecayValue.textContent = val.toFixed(1);
            if (reverb) reverb.decay = val;
        });

        reverbWet.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            reverbWetValue.textContent = val.toFixed(2);
            if (reverb) reverb.wet.value = val;
        });
// --- ãƒ˜ãƒ«ãƒ‘ãƒ¼: ãƒãƒ¼ãƒ‰ã¸ç›´æ¥å®‰å…¨ã«å€¤ã‚’æ›¸ãè¾¼ã‚€ ---
function setDistortionNodeValue(node, val) {
    if (!node) return;
    try {
        // Tone.Distortion ã¯å®Ÿè£…å·®ãŒã‚ã‚‹ãŸã‚è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œ
        if (node.distortion && typeof node.distortion === 'object' && 'value' in node.distortion) {
            node.distortion.value = val;
        } else if ('distortion' in node) {
            node.distortion = val;
        } else if (typeof node.set === 'function') {
            // Toneã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® set() ã‚’ä½¿ãˆã‚‹å ´åˆ
            node.set({ distortion: val });
        } else {
            console.warn('Unknown distortion property shape', node);
        }
        console.log(`Distortion set -> ${val}`);
    } catch (err) {
        console.warn('Failed to set distortion on node:', err);
    }
}

function setEqFilterGain(filterNode, val) {
    if (!filterNode) return;
    try {
        if (filterNode.gain && typeof filterNode.gain === 'object' && 'value' in filterNode.gain) {
            filterNode.gain.value = val;
        } else if ('gain' in filterNode) {
            filterNode.gain = val;
        } else if (typeof filterNode.set === 'function') {
            filterNode.set({ gain: val });
        } else {
            console.warn('Unknown filter gain shape', filterNode);
        }
        console.log(`Filter(${filterNode.frequency ? filterNode.frequency.value : 'freq?'}) gain set -> ${val}`);
    } catch (err) {
        console.warn('Failed to set filter gain:', err);
    }
}

        // --- AI ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆæ©Ÿèƒ½ ---

const setSliderValue = (slider, value, valueSpan = null, precision = 1) => {
    if (value !== undefined && slider) {
        const floatValue = parseFloat(value);
        if (isNaN(floatValue)) {
            console.warn(`Skipping invalid value for slider ${slider.id}: ${value}`);
            return;
        }
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        const finalValue = Math.max(min, Math.min(max, floatValue));
        slider.value = finalValue;

        if (valueSpan) {
            valueSpan.textContent = finalValue.toFixed(precision);
        }

        // ç™ºç«ã¯ãƒãƒ–ãƒªãƒ³ã‚°ã™ã‚‹ input ã‚¤ãƒ™ãƒ³ãƒˆã§ç¢ºå®Ÿã«é€šçŸ¥
        slider.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    }
};


        // Gemini APIå‘¼ã³å‡ºã—
const API_KEY = "AIzaSyDElRUWtipalplrZijKNc3GIrLQ-zzYtJE"; // â† â˜… ã“ã“ã«ä¸€æ™‚çš„ã«ç›´æ›¸ã
const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";
async function callGeminiApi(apiUrl, apiKey, promptBody) {
  const res = await fetch(apiUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-goog-api-key": apiKey
    },
    body: JSON.stringify(promptBody)
  });
  return await res.json();
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼: dB -> ãƒªãƒ‹ã‚¢ã‚²ã‚¤ãƒ³
function dbToLinear(db) {
  return Math.pow(10, db / 20);
}

// ã‚¯ãƒ©ãƒ³ãƒ—é–¢æ•°
function clampNumber(v, min, max, fallback) {
  const n = Number(v);
  if (!isFinite(n)) return fallback;
  if (n < min) return min;
  if (n > max) return max;
  return Math.round(n * 100) / 100; // 2 decimal places
}

// WaveShaper curve generator for simple distortion
function makeDistortionCurve(amount = 50, samples = 44100) {
  const curve = new Float32Array(samples);
  const k = typeof amount === "number" ? amount : 50;
  const deg = Math.PI / 180;
  for (let i = 0; i < samples; ++i ) {
    const x = (i * 2) / samples - 1;
    curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
  }
  return curve;
}

// ä¸»å‡¦ç†: modelã®å‡ºåŠ›ã‚’å—ã‘å–ã£ã¦WebAudioã¸é©ç”¨
async function applySettingsToAudio(audioContext, sourceNode, parsedJson) {
  const defaultSettings = {
    gain: 0,
    eq: [],
    distortion: { type: "waveshaper", drive: 0, tone: 0.5, mix: 0 },
    reverbWet: 0
  };

  const settings = parsedJson?.settings ? parsedJson.settings : defaultSettings;

  // validate / clamp
  const gainDb = clampNumber(settings.gain, -24, 24, 0);
  const reverbWet = clampNumber(settings.reverbWet, 0, 1, 0);

  const eqBands = Array.isArray(settings.eq) ? settings.eq.slice(0,5).map(b => ({
    type: b.type || "peaking",
    freq: clampNumber(b.freq, 20, 20000, 1000),
    gain: clampNumber(b.gain, -24, 24, 0),
    q: clampNumber(b.q, 0.1, 18.0, 1.0)
  })) : [];

  const distortion = settings.distortion || defaultSettings.distortion;
  const distType = distortion.type || "waveshaper";
  const drive = clampNumber(distortion.drive, 0, 1, 0);
  const tone = clampNumber(distortion.tone, 0, 1, 0.5);
  const mix = clampNumber(distortion.mix, 0, 1, 0);

  // Create nodes
  const masterGain = audioContext.createGain();
  masterGain.gain.value = dbToLinear(gainDb);

  // EQ chain (series of BiquadFilterNodes)
  let lastNode = sourceNode;
  const eqNodes = [];
  for (const band of eqBands) {
    const f = audioContext.createBiquadFilter();
    f.type = band.type; // 'lowshelf','peaking','highshelf'
    f.frequency.value = band.freq;
    f.gain.value = band.gain;
    f.Q.value = band.q;
    lastNode.connect(f);
    lastNode = f;
    eqNodes.push(f);
  }

  // Distortion
  const dryGain = audioContext.createGain();
  const wetGain = audioContext.createGain();
  dryGain.gain.value = 1 - mix;
  wetGain.gain.value = mix;

  lastNode.connect(dryGain);
  lastNode.connect(/* distortion node */);

  let distortionNode;
  if (distType === "waveshaper") {
    distortionNode = audioContext.createWaveShaper();
    // amount: map drive 0..1 -> curve intensity (e.g. 0..400)
    const amount = Math.max(1, Math.round(drive * 400));
    distortionNode.curve = makeDistortionCurve(amount);
    // optional: apply tone with a simple high-shelf after distortion
    const toneFilter = audioContext.createBiquadFilter();
    toneFilter.type = "highshelf";
    // tone 0 => darker (low gain), 1 => bright (high gain)
    toneFilter.gain.value = (tone - 0.5) * 24; // map to -12..+12 dB
    distortionNode.connect(toneFilter);
    toneFilter.connect(wetGain);
  } else if (distType === "softclip" || distType === "hardclip") {
    // Alternative implementations: oversample + waveshaper or script processor
    distortionNode = audioContext.createWaveShaper();
    distortionNode.curve = makeDistortionCurve(Math.max(1, Math.round(drive * 300)));
    distortionNode.connect(wetGain);
  } else {
    // fallback: passthrough
    distortionNode = audioContext.createGain();
    distortionNode.gain.value = 0;
    distortionNode.connect(wetGain);
  }

  lastNode.connect(distortionNode);

  // Reverb: for demo we just use ConvolverNode stub (should load IR in production)
  const convolver = audioContext.createConvolver(); // needs IR buffer to be useful
  const reverbWetGain = audioContext.createGain();
  reverbWetGain.gain.value = reverbWet;
  const reverbDryGain = audioContext.createGain();
  reverbDryGain.gain.value = 1 - reverbWet;

  // connect path: dry -> masterGain, wet (convolver) -> masterGain
  dryGain.connect(reverbDryGain);
  wetGain.connect(reverbDryGain); // distortion wet still goes to dry path (option)
  reverbDryGain.connect(masterGain);

  convolver.connect(reverbWetGain);
  reverbWetGain.connect(masterGain);

  // connect master to destination
  masterGain.connect(audioContext.destination);
}

// usage example (pseudo)
(async () => {
  // assume there is an <audio> element or MediaElementSourceNode
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const audioEl = document.querySelector("audio");
  const src = ctx.createMediaElementSource(audioEl);

  // 1) call the API (use your server endpoint ideally)
  const promptBody = {
    contents: [{ parts: [{ text: `
Return ONLY a valid JSON object and NOTHING ELSE.
Do not include explanations or text before/after the JSON.
If you cannot comply, return exactly "{}".

Schema:
{
  "description": string,
  "settings": {
    "gain": number,
    "eq": [
      {"type": "lowshelf|peaking|highshelf", "freq": number, "gain": number, "q": number}
    ],
    "distortion": {"type": "waveshaper", "drive": number, "tone": number, "mix": number},
    "reverbWet": number
  }
}
` }] }],
    temperature: 0.0,
    maxOutputTokens: 400,
    candidateCount: 1
  };
  // for illustration only; do not expose API key in front-end
  // const resp = await callGemini("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent", "YOUR_API_KEY", promptBody);
  // const rawText = resp?.candidates?.[0]?.content?.parts?.[0]?.text;

  // assume rawText is the JSON-string returned by model:
  // const parsed = JSON.parse(rawText);
  // await applySettingsToAudio(ctx, src, parsed);
})();


        // AIè¨­å®šã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨UIã«é©ç”¨ã™ã‚‹ 
function applyAiSettings() {
    if (!currentAiSettings) return;

    if (!player) {
        aiStatus.textContent = "ã‚¨ãƒ©ãƒ¼: AIè¨­å®šã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€å…ˆã«éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚";
        return;
    }

    const settings = currentAiSettings;

    // 1) ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ›´æ–°ï¼ˆUI æ›´æ–°ã¨ input ã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºç«ï¼‰
    setSliderValue(gainSlider, settings.gain, gainValue, 1);
    setSliderValue(rateSlider, settings.rate, rateValue, 2);
    setSliderValue(pitchSlider, settings.pitch, pitchValue, 0);

    setSliderValue(compThreshold, settings.compressorThreshold, compThresholdValue, 0);
    setSliderValue(compRatio, settings.compressorRatio, compRatioValue, 1);
    setSliderValue(distAmount, settings.distortionAmount, distAmountValue, 2);

    eqSliders.forEach((eq) => {
        const aiValue = settings[eq.aiKey];
        setSliderValue(eq.el, aiValue, eq.valEl, 1);
    });

    setSliderValue(reverbDecay, settings.reverbDecay, reverbDecayValue, 1);
    setSliderValue(reverbWet, settings.reverbWet, reverbWetValue, 2);

    // 2) **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ãƒãƒ¼ãƒ‰ã¸ç›´æ¥åæ˜ **ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆãŒèµ°ã‚‰ãªã‹ã£ãŸ / å‹å·®ãŒã‚ã‚‹å ´åˆã®ä¿é™ºï¼‰
    // Distortion
    if (typeof settings.distortionAmount !== 'undefined') {
        setDistortionNodeValue(distortion, parseFloat(settings.distortionAmount));
    }

    // EQ ã®å„ãƒ•ã‚£ãƒ«ã‚¿ã«ç›´æ¥æ›¸ãè¾¼ã‚€ï¼ˆeqFilters ãŒãã¡ã‚“ã¨ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼‰
    if (eqFilters && Array.isArray(eqFilters)) {
        eqSliders.forEach((eq, idx) => {
            const aiValue = settings[eq.aiKey];
            if (typeof aiValue !== 'undefined' && eqFilters[idx]) {
                setEqFilterGain(eqFilters[idx], parseFloat(aiValue));
            }
        });
    } else {
        console.warn('eqFilters not initialized yet when applying AI settings');
    }

    aiStatus.textContent = "AIã«ã‚ˆã‚‹è¨­å®šã‚’é©ç”¨ã—ã¾ã—ãŸã€‚UIã«åæ˜ ã•ã‚Œã¦ã„ã¾ã™ã€‚";
}


        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        aiGenerateBtn.addEventListener('click', async () => {
    const prompt = aiPrompt.value.trim();
    if (!prompt) {
        aiStatus.textContent = "ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã«è¦æœ›ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
        return;
    }

    aiStatus.textContent = "AIã«å•ã„åˆã‚ã›ä¸­...";
    try {
        const promptBody = {
            contents: [{
                parts: [{
                    text: `
ã‚ãªãŸã¯éŸ³éŸ¿ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚
æ¬¡ã®è¦æœ›ã«åˆã†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®šã‚’ **JSON ã®ã¿ã§å‡ºåŠ›** ã—ã¦ãã ã•ã„ã€‚

ğŸš«ç¦æ­¢äº‹é …ï¼š
- ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆ\`\`\`ï¼‰ã‚’ä½¿ã‚ãªã„
- ã‚³ãƒ¡ãƒ³ãƒˆã‚„èª¬æ˜æ–‡ã‚’å…¥ã‚Œãªã„
- JSONä»¥å¤–ã®å‡ºåŠ›ã‚’ã—ãªã„

å¿…ãšä»¥ä¸‹ã®JSONã‚¹ã‚­ãƒ¼ãƒã«æº–æ‹ ã—ã€å„æ•°å€¤ã¯æŒ‡å®šç¯„å›²ã‚’å³å®ˆã—ã¦ãã ã•ã„ï¼š

{
  "gain": number,                // å‡ºåŠ›éŸ³é‡ [-40.0 ï½ 10.0] dB
  "rate": number,                // å†ç”Ÿé€Ÿåº¦ [0.50 ï½ 2.00] å€
  "pitch": number,               // ãƒ”ãƒƒãƒãƒ™ãƒ³ãƒ‰ [-1200 ï½ 1200] ã‚»ãƒ³ãƒˆ
  "compressorThreshold": number, // ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼é–¾å€¤ [-60 ï½ 0] dB
  "compressorRatio": number,     // ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼æ¯”ç‡ [1 ï½ 20]
  "distortionAmount": number,    // ãƒ‡ã‚£ã‚¹ãƒˆãƒ¼ã‚·ãƒ§ãƒ³å¼·åº¦ [0.00 ï½ 1.00]
  "eq1_60hz": number,            // EQ 60Hzå¸¯ [-20.0 ï½ +20.0] dB
  "eq2_250hz": number,           // EQ 250Hzå¸¯ [-20.0 ï½ +20.0] dB
  "eq3_1khz": number,            // EQ 1kHzå¸¯ [-20.0 ï½ +20.0] dB
  "eq4_4khz": number,            // EQ 4kHzå¸¯ [-20.0 ï½ +20.0] dB
  "eq5_10khz": number,           // EQ 10kHzå¸¯ [-20.0 ï½ +20.0] dB
  "reverbDecay": number,         // ãƒªãƒãƒ¼ãƒ–æ¸›è¡°æ™‚é–“ [0.1 ï½ 10.0] ç§’
  "reverbWet": number            // ãƒªãƒãƒ¼ãƒ–ã®ã‚¦ã‚§ãƒƒãƒˆé‡ [0.00 ï½ 1.00]
}

è¦æœ›: ${prompt}
`
                }]
            }]
        };

const res = await fetch(API_URL, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "X-goog-api-key": API_KEY
  },
  body: JSON.stringify(promptBody)
});

const data = await res.json();
const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "{}";

const jsonText = text
  .replace(/```json\s*/i, "")
  .replace(/```/g, "")
  .trim();

let parsed;
try {
  parsed = JSON.parse(jsonText);
} catch (err) {
  aiStatus.textContent = "AIã®å‡ºåŠ›ã‚’è§£æã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚";
  console.error("JSON parse error:", err, "AI output:", text);
  return;
}

currentAiSettings = parsed;
aiResponseArea.textContent = JSON.stringify(parsed, null, 2);
aiStatus.textContent = "AIè¨­å®šã‚’å–å¾—ã—ã¾ã—ãŸã€‚ï¼»è¨­å®šã‚’é©ç”¨ï¼½ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
aiApplyBtn.disabled = false;

    } catch (err) {
        console.error(err);
        aiStatus.textContent = `ã‚¨ãƒ©ãƒ¼: AIã¨ã®é€šä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ (${err.message})`;
    }
});


        aiApplyBtn.addEventListener('click', applyAiSettings);


        // --- ã‚¢ãƒŠãƒ©ã‚¤ã‚¶æç”» ---
        function drawAnalysers() {
            requestAnimationFrame(drawAnalysers);

            if (!isInitialized) return;

            // Waveform (æ™‚é–“é ˜åŸŸ)
            const waveData = analyserWave.getValue();
            const waveWidth = waveformCanvas.width;
            const waveHeight = waveformCanvas.height;
            waveformCtx.clearRect(0, 0, waveWidth, waveHeight);
            waveformCtx.lineWidth = 2;
            waveformCtx.strokeStyle = 'rgb(66, 153, 225)'; // Blue-500
            waveformCtx.beginPath();

            const sliceWidth = waveWidth * 1.0 / waveData.length;
            let x = 0;

            for (let i = 0; i < waveData.length; i++) {
                const v = waveData[i];
                const y = (v + 1) / 2 * waveHeight;

                if (i === 0) {
                    waveformCtx.moveTo(x, y);
                } else {
                    waveformCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            waveformCtx.lineTo(waveWidth, waveHeight / 2);
            waveformCtx.stroke();

            // FFT (å‘¨æ³¢æ•°é ˜åŸŸ)
            const fftData = analyserFft.getValue();
            const fftWidth = fftCanvas.width;
            const fftHeight = fftCanvas.height;
            fftCtx.clearRect(0, 0, fftWidth, fftHeight);

            const barWidth = (fftWidth / fftData.length) * 2.5;
            let barX = 0;

            for (let i = 0; i < fftData.length; i++) {
                // dBå€¤ã‚’é«˜ã•ã«å¤‰æ› (-100dBã‹ã‚‰0dBã®ç¯„å›²ã‚’0ã‹ã‚‰100%ã«ãƒãƒƒãƒ”ãƒ³ã‚°)
                let percent = (fftData[i] + 100) / 100;
                let barHeight = percent * fftHeight;

                // æœ€å°å€¤ã‚’è¨­å®šã—ã¦ãƒãƒ¼ãŒæ¶ˆãˆãªã„ã‚ˆã†ã«ã™ã‚‹
                barHeight = Math.max(2, barHeight); 

                fftCtx.fillStyle = `rgb(109, 40, 217, ${percent + 0.2})`; // Purple-700
                fftCtx.fillRect(barX, fftHeight - barHeight, barWidth, barHeight);

                barX += barWidth + 1;
            }
        } 
    </script>
</body>
</html>
