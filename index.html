<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オーディオプレイヤー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN (Web Audio Framework) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Interフォントの読み込み */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* iOSでのオーバースクロールによるバウンスを防ぐ */
            overscroll-behavior: none;
        }
        /* スライダーの見た目をカスタマイズ */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        /* スライダー トラック (Chrome, Safari, Edge) */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #e5e7eb; /* gray-200 */
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        /* スライダー つまみ (Chrome, Safari, Edge) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -4px; /* トラックの中央に配置 */
            background-color: #3b82f6; /* blue-500 */
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            border: 2px solid white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        /* スライダー トラック (Firefox) */
        input[type="range"]::-moz-range-track {
            background: #e5e7eb; /* gray-200 */
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        /* スライダー つまみ (Firefox) */
        input[type="range"]::-moz-range-thumb {
            background-color: #3b82f6; /* blue-500 */
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            border: 2px solid white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        /* EQスライダー (縦) */
        .vertical-slider-container {
            writing-mode: bt-lr; /* IE/Edge */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 2rem;
            height: 120px;
            padding: 0;
        }
        .vertical-slider-container input[type="range"] {
            width: 120px;
            height: 2rem;
            margin: 0;
            transform-origin: 70px 70px; /* 回転の中心を調整 */
            transform: rotate(-90deg);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-8 space-y-6">
        
        <h1 class="text-3xl font-bold text-center text-blue-600">Audio FX Player</h1>
        
        <!-- 1. ファイル入力 -->
        <div class="border-b pb-6">
            <label for="file-input" class="block text-sm font-medium text-gray-700 mb-2">1. 音声ファイルを選択</label>
            <input id="file-input" type="file" class="block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-50 file:text-blue-700
                hover:file:bg-blue-100
                cursor-pointer
            ">
            <p id="loading-status" class="text-sm text-blue-600 mt-2"></p>
        </div>

        <!-- 2. 再生コントロール -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 border-b pb-6">
            <button id="play-pause-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                再生
            </button>
            <button id="stop-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                停止
            </button>
            
            <!-- ループ -->
            <label for="loop-toggle" class="flex items-center justify-center bg-gray-100 p-3 rounded-lg shadow-inner cursor-pointer">
                <input type="checkbox" id="loop-toggle" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                <span class="ml-3 font-medium text-gray-700">ループ</span>
            </label>

            <!-- オフタイマー -->
            <div class="flex items-center space-x-2 bg-gray-100 p-3 rounded-lg shadow-inner">
                <input type="number" id="timer-input" min="1" placeholder="分" class="w-16 p-2 rounded-md border border-gray-300 text-sm focus:ring-blue-500 focus:border-blue-500">
                <button id="timer-btn" class="bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium py-2 px-3 rounded-md shadow transition duration-200">
                    タイマー
                </button>
            </div>
            <p id="timer-status" class="text-sm text-green-600 col-span-full text-center mt-2"></p>
        </div>

        <!-- 3. メインコントロール -->
        <div class="grid md:grid-cols-3 gap-6 border-b pb-6">
            <!-- マスターGain -->
            <div class_controls>
                <label for="gain-slider" class="block text-sm font-medium text-gray-700">マスターGain (<span id="gain-value">0</span> dB)</label>
                <input id="gain-slider" type="range" min="-40" max="10" value="0" step="0.5" class="mt-2">
            </div>
            <!-- 再生速度 (ピッチ不変) -->
            <div class_controls>
                <label for="rate-slider" class="block text-sm font-medium text-gray-700">再生速度 (<span id="rate-value">1.00</span> x)</label>
                <input id="rate-slider" type="range" min="0.5" max="2.0" value="1.0" step="0.01" class="mt-2">
            </div>
            <!-- ピッチベンド (速度不変) -->
            <div class_controls>
                <label for="pitch-slider" class="block text-sm font-medium text-gray-700">ピッチ (<span id="pitch-value">0</span> セント)</label>
                <input id="pitch-slider" type="range" min="-1200" max="1200" value="0" step="1" class="mt-2">
            </div>
        </div>

        <!-- 4. エフェクト -->
        <div class="space-y-6 border-b pb-6">
            <h2 class="text-xl font-semibold text-gray-800">エフェクト</h2>
            
            <!-- コンプレッサー & ディストーション -->
            <div class="grid md:grid-cols-2 gap-6">
                <!-- コンプレッサー -->
                <div>
                    <h3 class="font-medium text-gray-700 mb-2">コンプレッサー</h3>
                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner space-y-3">
                        <div>
                            <label for="comp-threshold" class="text-sm">Threshold (<span id="comp-threshold-value">-24</span> dB)</label>
                            <input id="comp-threshold" type="range" min="-60" max="0" value="-24" step="1">
                        </div>
                        <div>
                            <label for="comp-ratio" class="text-sm">Ratio (<span id="comp-ratio-value">12</span>:1)</label>
                            <input id="comp-ratio" type="range" min="1" max="20" value="12" step="0.5">
                        </div>
                    </div>
                </div>
                <!-- ディストーション -->
                <div>
                    <h3 class="font-medium text-gray-700 mb-2">ディストーション</h3>
                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner space-y-3">
                        <div>
                            <label for="dist-amount" class="text-sm">Amount (<span id="dist-amount-value">0.00</span>)</label>
                            <input id="dist-amount" type="range" min="0" max="1" value="0" step="0.01">
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5バンドイコライザー -->
            <div>
                <h3 class="font-medium text-gray-700 mb-2">5バンド イコライザー (dB)</h3>
                <div class="p-4 bg-gray-50 rounded-lg shadow-inner flex justify-around items-end space-x-2">
                    <!-- 60Hz -->
                    <div class="text-center">
                        <span id="eq1-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq1" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">60Hz</label>
                    </div>
                    <!-- 250Hz -->
                    <div class="text-center">
                        <span id="eq2-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq2" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">250Hz</label>
                    </div>
                    <!-- 1kHz -->
                    <div class="text-center">
                        <span id="eq3-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq3" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">1kHz</label>
                    </div>
                    <!-- 4kHz -->
                    <div class="text-center">
                        <span id="eq4-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq4" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">4kHz</label>
                    </div>
                    <!-- 10kHz -->
                    <div class="text-center">
                        <span id="eq5-value" class="text-sm font-medium">0.0</span>
                        <div class="vertical-slider-container my-2">
                            <input id="eq5" type="range" min="-20" max="20" value="0" step="0.5" class="eq-slider">
                        </div>
                        <label class="text-xs font-medium text-gray-600">10kHz</label>
                    </div>
                </div>
            </div>

            <!-- リバーブ -->
            <div>
                <h3 class="font-medium text-gray-700 mb-2">リバーブ</h3>
                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner space-y-3">
                    <div>
                        <label for="reverb-decay" class="text-sm">Decay (s) (<span id="reverb-decay-value">1.5</span>)</label>
                        <input id="reverb-decay" type="range" min="0.1" max="10" value="1.5" step="0.1">
                    </div>
                    <div>
                        <label for="reverb-wet" class="text-sm">Wet (<span id="reverb-wet-value">0.00</span>)</label>
                        <input id="reverb-wet" type="range" min="0" max="1" value="0" step="0.01">
                    </div>
                </div>
            </div>
        </div>

        <!-- 4.5.  Gemini AI アシスタント -->
        <div class="space-y-4 border-b pb-6">
            <h2 class="text-xl font-semibold text-gray-800"> AI エフェクト アシスタント</h2>
            <div class="p-4 bg-gradient-to-br from-blue-50 to-purple-50 rounded-lg shadow-inner space-y-3">
                <label for="ai-prompt" class="block text-sm font-medium text-gray-700">どのようなサウンドにしたいですか？</label>
                <textarea id="ai-prompt" rows="2" class="w-full p-2 rounded-md border border-gray-300 focus:ring-blue-500 focus:border-blue-500" placeholder="例: ポッドキャスト風, ボーカルをクリアに, AMラジオ風のサウンド"></textarea>
                <button id="ai-generate-btn" class="w-full bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-200">
                    設定を生成
                </button>
                <div id="ai-response-area" class="mt-3 p-3 bg-white rounded-md border border-gray-200 min-h-[50px] text-sm text-gray-700">
                    <p id="ai-status" class="text-gray-500">ここにAIからの提案が表示されます。</p>
                </div>
                <button id="ai-apply-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    設定を適用
                </button>
            </div>
        </div>


        <!-- 5. ビジュアルアナライザ -->
        <div>
            <h2 class="text-xl font-semibold text-gray-800 mb-4">ビジュアルアナライザ</h2>
            <div class="grid md:grid-cols-2 gap-4">
                <div>
                    <h3 class="font-medium text-gray-700 mb-2 text-center">波形 (Waveform)</h3>
                    <canvas id="waveform-canvas" class="w-full h-32 bg-gray-900 rounded-lg shadow-inner"></canvas>
                </div>
                <div>
                    <h3 class="font-medium text-gray-700 mb-2 text-center">周波数 (FFT)</h3>
                    <canvas id="fft-canvas" class="w-full h-32 bg-gray-900 rounded-lg shadow-inner"></canvas>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // DOM要素の取得
        const fileInput = document.getElementById('file-input');
        const loadingStatus = document.getElementById('loading-status');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const loopToggle = document.getElementById('loop-toggle');
        const timerInput = document.getElementById('timer-input');
        const timerBtn = document.getElementById('timer-btn');
        const timerStatus = document.getElementById('timer-status');

        const gainSlider = document.getElementById('gain-slider');
        const gainValue = document.getElementById('gain-value');
        const rateSlider = document.getElementById('rate-slider');
        const rateValue = document.getElementById('rate-value');
        const pitchSlider = document.getElementById('pitch-slider');
        const pitchValue = document.getElementById('pitch-value');

        const compThreshold = document.getElementById('comp-threshold');
        const compThresholdValue = document.getElementById('comp-threshold-value');
        const compRatio = document.getElementById('comp-ratio');
        const compRatioValue = document.getElementById('comp-ratio-value');
        const distAmount = document.getElementById('dist-amount');
        const distAmountValue = document.getElementById('dist-amount-value');

        const reverbDecay = document.getElementById('reverb-decay');
        const reverbDecayValue = document.getElementById('reverb-decay-value');
        const reverbWet = document.getElementById('reverb-wet');
        const reverbWetValue = document.getElementById('reverb-wet-value');

        // ★ 修正: aiKeyを追加し、AI設定との対応を明確化
        const eqSliders = [
            { el: document.getElementById('eq1'), freq: 60, valEl: document.getElementById('eq1-value'), aiKey: 'eq1_60hz' },
            { el: document.getElementById('eq2'), freq: 250, valEl: document.getElementById('eq2-value'), aiKey: 'eq2_250hz' },
            { el: document.getElementById('eq3'), freq: 1000, valEl: document.getElementById('eq3-value'), aiKey: 'eq3_1khz' },
            { el: document.getElementById('eq4'), freq: 4000, valEl: document.getElementById('eq4-value'), aiKey: 'eq4_4khz' },
            { el: document.getElementById('eq5'), freq: 10000, valEl: document.getElementById('eq5-value'), aiKey: 'eq5_10khz' }
        ];

        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const fftCanvas = document.getElementById('fft-canvas');
        const fftCtx = fftCanvas.getContext('2d');

        // AIアシスタントDOM
        const aiPrompt = document.getElementById('ai-prompt');
        const aiGenerateBtn = document.getElementById('ai-generate-btn');
        const aiResponseArea = document.getElementById('ai-response-area');
        const aiStatus = document.getElementById('ai-status');
        const aiApplyBtn = document.getElementById('ai-apply-btn');


        // Tone.jsのセットアップ
        let player, masterGain, compressor, distortion, eqFilters, reverb, analyserWave, analyserFft;
        let isPlaying = false;
        let isInitialized = false;
        let audioReady = false;
        let stopTimer = null;
        let currentAiSettings = null; // AIが生成した設定を保持

        // アナライザのキャンバスサイズ設定
        function setupCanvas(canvas, ctx) {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = canvas.offsetHeight;
        }

        // オーディオノードの初期化と接続
        function initializeAudioNodes() {
    if (isInitialized) return;

    // マスターは dB 単位で作るが、最終 destination へは masterGain を経由して接続する
    masterGain = new Tone.Gain({ gain: parseFloat(gainSlider.value), units: 'decibels' });
    // 分析用に Analyser を作る（タップ用）
    analyserWave = new Tone.Analyser('waveform', 1024);
    analyserFft = new Tone.Analyser('fft', 256);

    // リバーブは toDestination() に直接つなげない（必ず masterGain を通す）
    reverb = new Tone.Reverb({
        decay: parseFloat(reverbDecay.value),
        // wetはAudioParamっぽいので初期値はここに
        wet: parseFloat(reverbWet.value)
    });

    compressor = new Tone.Compressor({
        threshold: parseFloat(compThreshold.value),
        ratio: parseFloat(compRatio.value)
    });

    // 5バンドEQ を作る（peaking）。gainはAudioParamなので初期値を与える
    eqFilters = eqSliders.map(eq => {
        return new Tone.Filter({
            type: 'peaking',
            frequency: eq.freq,
            Q: 1,
            gain: parseFloat(eq.el.value)
        });
    });

    // Distortion
    distortion = new Tone.Distortion(parseFloat(distAmount.value));

    // --- 接続チェーン（明確に masterGain を最後に通す） ---
    // Player -> Distortion -> Compressor -> ...eqFilters -> Reverb -> masterGain -> Destination
    distortion.connect(compressor);
    compressor.chain(...eqFilters);
    eqFilters[eqFilters.length - 1].connect(reverb);

    // reverb -> masterGain -> destination
    reverb.connect(masterGain);
    masterGain.toDestination();

    // --- アナライザは「タップ」で接続（チェーンに挟まない） ---
    // 再生信号の観測点として reverb 出力と masterGain 出力をタップ
    reverb.connect(analyserWave);     // 波形はリバーブ後を観測
    masterGain.connect(analyserFft);  // FFT は最終出力を観測

    // Canvas をセットアップして描画ループ開始
    setupCanvas(waveformCanvas, waveformCtx);
    setupCanvas(fftCanvas, fftCtx);
    drawAnalysers();

    isInitialized = true;
}

        // ファイル入力
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            loadingStatus.textContent = '読み込み中...';
            playPauseBtn.disabled = true;
            stopBtn.disabled = true;
            audioReady = false;

            if (player) {
                player.stop();
                player.unsync(); // Transportとの同期を解除
                player.dispose(); // 古いプレイヤーを破棄
            }

            // Transportを停止・リセット
            if (isInitialized) {
                Tone.Transport.stop();
                Tone.Transport.position = 0;
                isPlaying = false;
                playPauseBtn.textContent = '再生';
            }

            const url = URL.createObjectURL(file);
            
            try {
                await Tone.start();
                initializeAudioNodes();

                player = new Tone.Player(url, () => {
                    // 読み込み完了コールバック
                    loadingStatus.textContent = `読み込み完了: ${file.name}`;
                    playPauseBtn.disabled = false;
                    stopBtn.disabled = false;
                    audioReady = true;

                    // プレイヤーをエフェクトチェーンの先頭に接続
                    if (distortion) {
                        player.connect(distortion);
                    } else {
                        // 異常系: distortionノードがなければmasterGainに直接接続
                        player.connect(masterGain);
                    }

                    // ループ機能の初期設定をUIに同期させる
                    const isLooping = loopToggle.checked;
                    player.loop = isLooping; 
                    
                    if (isInitialized) {
                        Tone.Transport.loopEnd = player.buffer.duration;
                        Tone.Transport.loopStart = 0;
                        Tone.Transport.loop = isLooping;
                    }
                    
                    // 初期ピッチ/レート設定の適用
                    const initialRate = parseFloat(rateSlider.value);
                    const initialUserPitch = parseFloat(pitchSlider.value);
                    const initialCorrection = 1200 * Math.log2(1 / initialRate); 

                    player.playbackRate = initialRate;
                    player.detune = initialUserPitch + initialCorrection;

                    // Transportに同期して再生（Transportはまだ開始していない）
                    player.sync().start(0);
                });
                
                // 再生終了時の処理 (Transport連携)
                player.onstop = () => {
                    if (Tone.Transport.state === 'started' && !player.loop) {
                         Tone.Transport.stop();
                         Tone.Transport.position = 0;
                         isPlaying = false;
                         playPauseBtn.textContent = '再生';
                    }
                };
                
            } catch (error) {
                loadingStatus.textContent = `エラー: ファイルの読み込みに失敗しました (${error.message})`;
                console.error("Audio Load Error:", error);
            }
        });

        // 再生・一時停止
        playPauseBtn.addEventListener('click', async () => {
            if (!audioReady) return;
            await Tone.start();
            initializeAudioNodes();

            if (Tone.Transport.state === 'started') {
                Tone.Transport.pause();
                isPlaying = false;
                playPauseBtn.textContent = '再生';
            } else {
                Tone.Transport.start();
                isPlaying = true;
                playPauseBtn.textContent = '一時停止';
            }
        });

        // 停止
        stopBtn.addEventListener('click', () => {
            if (!audioReady) return;
            Tone.Transport.stop();
            Tone.Transport.position = 0; 
            isPlaying = false;
            playPauseBtn.textContent = '再生';
        });

        // ループ
        loopToggle.addEventListener('change', (e) => {
            const isLooping = e.target.checked;
            if (player) {
                player.loop = isLooping;
                if (isInitialized) {
                    Tone.Transport.loop = isLooping;
                    if (player.buffer) {
                        Tone.Transport.loopEnd = player.buffer.duration;
                    }
                }
            }
        });

        // オフタイマー
        timerBtn.addEventListener('click', () => {
            if (stopTimer) {
                clearTimeout(stopTimer);
                stopTimer = null;
                timerStatus.textContent = 'タイマーをキャンセルしました。';
                return;
            }

            const minutes = parseInt(timerInput.value);
            if (isNaN(minutes) || minutes <= 0) {
                timerStatus.textContent = '有効な分数 (1分以上) を入力してください。';
                return;
            }

            const ms = minutes * 60 * 1000;
            timerStatus.textContent = `${minutes}分後に自動停止します。`;
            timerInput.value = '';

            stopTimer = setTimeout(() => {
                if (isPlaying) {
                    if (player) {
                        player.stop();
                    }
                    Tone.Transport.stop();
                    Tone.Transport.position = 0;
                    isPlaying = false;
                    playPauseBtn.textContent = '再生';
                }
                timerStatus.textContent = 'タイマー終了 - 自動停止しました。';
                stopTimer = null;
            }, ms);
        });

        // --- スライダーコントロール ---

        // Gain
        gainSlider.addEventListener('input', (e) => {
            const db = parseFloat(e.target.value);
            gainValue.textContent = db.toFixed(1);
            if (masterGain) {
                masterGain.gain.value = db;
            }
        });

        // 速度とピッチの連動制御 (再生速度)
        rateSlider.addEventListener('input', (e) => {
            const rate = parseFloat(e.target.value);
            rateValue.textContent = rate.toFixed(2);
            if (player) {
                // 1. 再生速度の変更
                player.playbackRate = rate;

                // 2. ピッチ補正: 速度を変えてもピッチスライダーの値（userPitch）を維持する
                const speedCorrection = 1200 * Math.log2(1 / rate);
                const userPitch = parseFloat(pitchSlider.value);
                player.detune = userPitch + speedCorrection;
            }
        });

        // ピッチベンド (速度不変)
        pitchSlider.addEventListener('input', (e) => {
            const userPitch = parseFloat(e.target.value);
            pitchValue.textContent = userPitch.toFixed(0);
            if (player) {
                const rate = parseFloat(rateSlider.value);
                const speedCorrection = 1200 * Math.log2(1 / rate);
                const detuneValue = userPitch + speedCorrection;
        
                if (player.detune && typeof player.detune === 'object' && 'value' in player.detune) {
                    player.detune.value = detuneValue;
                } else {
                    player.set({ detune: detuneValue }); // ← Tone.js推奨の書き方
                }
            }
        });

        // コンプレッサー
        compThreshold.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            compThresholdValue.textContent = val.toFixed(0);
            if (compressor) compressor.threshold.value = val;
        });

        compRatio.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            compRatioValue.textContent = val.toFixed(1);
            if (compressor) compressor.ratio.value = val;
        });

        // ディストーション
        distAmount.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            distAmountValue.textContent = val.toFixed(2);
            if (distortion) {
                // Tone.Distortion の実装差で property が AudioParam か number かが違う場合があるため両方に対応
                if (distortion.distortion && typeof distortion.distortion === 'object' && 'value' in distortion.distortion) {
                    distortion.distortion.value = val;
                } else {
                    try { distortion.distortion = val; } catch (err) { console.warn('Cannot set distortion.distortion directly', err); }
                }
            }
        });

        // EQ
eqSliders.forEach((eq, index) => {
    eq.el.addEventListener('input', (e) => {
        const gain = parseFloat(e.target.value);
        eq.valEl.textContent = gain.toFixed(1);
        if (eqFilters && eqFilters[index]) {
            // gain は AudioParam のはずなので .gain.value を使う
            if (eqFilters[index].gain && 'value' in eqFilters[index].gain) {
                eqFilters[index].gain.value = gain;
            } else {
                // まれにオブジェクト直書きが必要ならフォールバック
                try { eqFilters[index].gain = gain; } catch (err) { console.warn('Cannot set filter gain directly', err); }
            }
        }
    });
});

        // リバーブ
        reverbDecay.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            reverbDecayValue.textContent = val.toFixed(1);
            if (reverb) reverb.decay = val;
        });

        reverbWet.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            reverbWetValue.textContent = val.toFixed(2);
            if (reverb) reverb.wet.value = val;
        });
// --- ヘルパー: ノードへ直接安全に値を書き込む ---
function setDistortionNodeValue(node, val) {
    if (!node) return;
    try {
        // Tone.Distortion は実装差があるため複数パターンに対応
        if (node.distortion && typeof node.distortion === 'object' && 'value' in node.distortion) {
            node.distortion.value = val;
        } else if ('distortion' in node) {
            node.distortion = val;
        } else if (typeof node.set === 'function') {
            // Toneオブジェクトの set() を使える場合
            node.set({ distortion: val });
        } else {
            console.warn('Unknown distortion property shape', node);
        }
        console.log(`Distortion set -> ${val}`);
    } catch (err) {
        console.warn('Failed to set distortion on node:', err);
    }
}

function setEqFilterGain(filterNode, val) {
    if (!filterNode) return;
    try {
        if (filterNode.gain && typeof filterNode.gain === 'object' && 'value' in filterNode.gain) {
            filterNode.gain.value = val;
        } else if ('gain' in filterNode) {
            filterNode.gain = val;
        } else if (typeof filterNode.set === 'function') {
            filterNode.set({ gain: val });
        } else {
            console.warn('Unknown filter gain shape', filterNode);
        }
        console.log(`Filter(${filterNode.frequency ? filterNode.frequency.value : 'freq?'}) gain set -> ${val}`);
    } catch (err) {
        console.warn('Failed to set filter gain:', err);
    }
}

        // --- AI アシスタント機能 ---

const setSliderValue = (slider, value, valueSpan = null, precision = 1) => {
    if (value !== undefined && slider) {
        const floatValue = parseFloat(value);
        if (isNaN(floatValue)) {
            console.warn(`Skipping invalid value for slider ${slider.id}: ${value}`);
            return;
        }
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        const finalValue = Math.max(min, Math.min(max, floatValue));
        slider.value = finalValue;

        if (valueSpan) {
            valueSpan.textContent = finalValue.toFixed(precision);
        }

        // 発火はバブリングする input イベントで確実に通知
        slider.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    }
};


        // Gemini API呼び出し
const API_KEY = "AIzaSyDElRUWtipalplrZijKNc3GIrLQ-zzYtJE"; // ← ★ ここに一時的に直書き
const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";
async function callGeminiApi(apiUrl, apiKey, promptBody) {
  const res = await fetch(apiUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-goog-api-key": apiKey
    },
    body: JSON.stringify(promptBody)
  });
  return await res.json();
}

// ヘルパー: dB -> リニアゲイン
function dbToLinear(db) {
  return Math.pow(10, db / 20);
}

// クランプ関数
function clampNumber(v, min, max, fallback) {
  const n = Number(v);
  if (!isFinite(n)) return fallback;
  if (n < min) return min;
  if (n > max) return max;
  return Math.round(n * 100) / 100; // 2 decimal places
}

// WaveShaper curve generator for simple distortion
function makeDistortionCurve(amount = 50, samples = 44100) {
  const curve = new Float32Array(samples);
  const k = typeof amount === "number" ? amount : 50;
  const deg = Math.PI / 180;
  for (let i = 0; i < samples; ++i ) {
    const x = (i * 2) / samples - 1;
    curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
  }
  return curve;
}

// 主処理: modelの出力を受け取ってWebAudioへ適用
async function applySettingsToAudio(audioContext, sourceNode, parsedJson) {
  const defaultSettings = {
    gain: 0,
    eq: [],
    distortion: { type: "waveshaper", drive: 0, tone: 0.5, mix: 0 },
    reverbWet: 0
  };

  const settings = parsedJson?.settings ? parsedJson.settings : defaultSettings;

  // validate / clamp
  const gainDb = clampNumber(settings.gain, -24, 24, 0);
  const reverbWet = clampNumber(settings.reverbWet, 0, 1, 0);

  const eqBands = Array.isArray(settings.eq) ? settings.eq.slice(0,5).map(b => ({
    type: b.type || "peaking",
    freq: clampNumber(b.freq, 20, 20000, 1000),
    gain: clampNumber(b.gain, -24, 24, 0),
    q: clampNumber(b.q, 0.1, 18.0, 1.0)
  })) : [];

  const distortion = settings.distortion || defaultSettings.distortion;
  const distType = distortion.type || "waveshaper";
  const drive = clampNumber(distortion.drive, 0, 1, 0);
  const tone = clampNumber(distortion.tone, 0, 1, 0.5);
  const mix = clampNumber(distortion.mix, 0, 1, 0);

  // Create nodes
  const masterGain = audioContext.createGain();
  masterGain.gain.value = dbToLinear(gainDb);

  // EQ chain (series of BiquadFilterNodes)
  let lastNode = sourceNode;
  const eqNodes = [];
  for (const band of eqBands) {
    const f = audioContext.createBiquadFilter();
    f.type = band.type; // 'lowshelf','peaking','highshelf'
    f.frequency.value = band.freq;
    f.gain.value = band.gain;
    f.Q.value = band.q;
    lastNode.connect(f);
    lastNode = f;
    eqNodes.push(f);
  }

  // Distortion
  const dryGain = audioContext.createGain();
  const wetGain = audioContext.createGain();
  dryGain.gain.value = 1 - mix;
  wetGain.gain.value = mix;

  lastNode.connect(dryGain);
  lastNode.connect(/* distortion node */);

  let distortionNode;
  if (distType === "waveshaper") {
    distortionNode = audioContext.createWaveShaper();
    // amount: map drive 0..1 -> curve intensity (e.g. 0..400)
    const amount = Math.max(1, Math.round(drive * 400));
    distortionNode.curve = makeDistortionCurve(amount);
    // optional: apply tone with a simple high-shelf after distortion
    const toneFilter = audioContext.createBiquadFilter();
    toneFilter.type = "highshelf";
    // tone 0 => darker (low gain), 1 => bright (high gain)
    toneFilter.gain.value = (tone - 0.5) * 24; // map to -12..+12 dB
    distortionNode.connect(toneFilter);
    toneFilter.connect(wetGain);
  } else if (distType === "softclip" || distType === "hardclip") {
    // Alternative implementations: oversample + waveshaper or script processor
    distortionNode = audioContext.createWaveShaper();
    distortionNode.curve = makeDistortionCurve(Math.max(1, Math.round(drive * 300)));
    distortionNode.connect(wetGain);
  } else {
    // fallback: passthrough
    distortionNode = audioContext.createGain();
    distortionNode.gain.value = 0;
    distortionNode.connect(wetGain);
  }

  lastNode.connect(distortionNode);

  // Reverb: for demo we just use ConvolverNode stub (should load IR in production)
  const convolver = audioContext.createConvolver(); // needs IR buffer to be useful
  const reverbWetGain = audioContext.createGain();
  reverbWetGain.gain.value = reverbWet;
  const reverbDryGain = audioContext.createGain();
  reverbDryGain.gain.value = 1 - reverbWet;

  // connect path: dry -> masterGain, wet (convolver) -> masterGain
  dryGain.connect(reverbDryGain);
  wetGain.connect(reverbDryGain); // distortion wet still goes to dry path (option)
  reverbDryGain.connect(masterGain);

  convolver.connect(reverbWetGain);
  reverbWetGain.connect(masterGain);

  // connect master to destination
  masterGain.connect(audioContext.destination);
}

// usage example (pseudo)
(async () => {
  // assume there is an <audio> element or MediaElementSourceNode
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const audioEl = document.querySelector("audio");
  const src = ctx.createMediaElementSource(audioEl);

  // 1) call the API (use your server endpoint ideally)
  const promptBody = {
    contents: [{ parts: [{ text: `
Return ONLY a valid JSON object and NOTHING ELSE.
Do not include explanations or text before/after the JSON.
If you cannot comply, return exactly "{}".

Schema:
{
  "description": string,
  "settings": {
    "gain": number,
    "eq": [
      {"type": "lowshelf|peaking|highshelf", "freq": number, "gain": number, "q": number}
    ],
    "distortion": {"type": "waveshaper", "drive": number, "tone": number, "mix": number},
    "reverbWet": number
  }
}
` }] }],
    temperature: 0.0,
    maxOutputTokens: 400,
    candidateCount: 1
  };
  // for illustration only; do not expose API key in front-end
  // const resp = await callGemini("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent", "YOUR_API_KEY", promptBody);
  // const rawText = resp?.candidates?.[0]?.content?.parts?.[0]?.text;

  // assume rawText is the JSON-string returned by model:
  // const parsed = JSON.parse(rawText);
  // await applySettingsToAudio(ctx, src, parsed);
})();


        // AI設定をスライダーとUIに適用する 
function applyAiSettings() {
    if (!currentAiSettings) return;

    if (!player) {
        aiStatus.textContent = "エラー: AI設定を適用するには、先に音声ファイルを読み込んでください。";
        return;
    }

    const settings = currentAiSettings;

    // 1) スライダーを更新（UI 更新と input イベントの発火）
    setSliderValue(gainSlider, settings.gain, gainValue, 1);
    setSliderValue(rateSlider, settings.rate, rateValue, 2);
    setSliderValue(pitchSlider, settings.pitch, pitchValue, 0);

    setSliderValue(compThreshold, settings.compressorThreshold, compThresholdValue, 0);
    setSliderValue(compRatio, settings.compressorRatio, compRatioValue, 1);
    setSliderValue(distAmount, settings.distortionAmount, distAmountValue, 2);

    eqSliders.forEach((eq) => {
        const aiValue = settings[eq.aiKey];
        setSliderValue(eq.el, aiValue, eq.valEl, 1);
    });

    setSliderValue(reverbDecay, settings.reverbDecay, reverbDecayValue, 1);
    setSliderValue(reverbWet, settings.reverbWet, reverbWetValue, 2);

    // 2) **フォールバックでノードへ直接反映**（イベントが走らなかった / 型差がある場合の保険）
    // Distortion
    if (typeof settings.distortionAmount !== 'undefined') {
        setDistortionNodeValue(distortion, parseFloat(settings.distortionAmount));
    }

    // EQ の各フィルタに直接書き込む（eqFilters がきちんと生成されているかチェック）
    if (eqFilters && Array.isArray(eqFilters)) {
        eqSliders.forEach((eq, idx) => {
            const aiValue = settings[eq.aiKey];
            if (typeof aiValue !== 'undefined' && eqFilters[idx]) {
                setEqFilterGain(eqFilters[idx], parseFloat(aiValue));
            }
        });
    } else {
        console.warn('eqFilters not initialized yet when applying AI settings');
    }

    aiStatus.textContent = "AIによる設定を適用しました。UIに反映されています。";
}


        // イベントリスナー
        aiGenerateBtn.addEventListener('click', async () => {
    const prompt = aiPrompt.value.trim();
    if (!prompt) {
        aiStatus.textContent = "テキストボックスに要望を入力してください。";
        return;
    }

    aiStatus.textContent = "AIに問い合わせ中...";
    try {
        const promptBody = {
            contents: [{
                parts: [{
                    text: `
あなたは音響エンジニアです。
次の要望に合うエフェクト設定を **JSON のみで出力** してください。

🚫禁止事項：
- コードブロック（\`\`\`）を使わない
- コメントや説明文を入れない
- JSON以外の出力をしない

必ず以下のJSONスキーマに準拠し、各数値は指定範囲を厳守してください：

{
  "gain": number,                // 出力音量 [-40.0 ～ 10.0] dB
  "rate": number,                // 再生速度 [0.50 ～ 2.00] 倍
  "pitch": number,               // ピッチベンド [-1200 ～ 1200] セント
  "compressorThreshold": number, // コンプレッサー閾値 [-60 ～ 0] dB
  "compressorRatio": number,     // コンプレッサー比率 [1 ～ 20]
  "distortionAmount": number,    // ディストーション強度 [0.00 ～ 1.00]
  "eq1_60hz": number,            // EQ 60Hz帯 [-20.0 ～ +20.0] dB
  "eq2_250hz": number,           // EQ 250Hz帯 [-20.0 ～ +20.0] dB
  "eq3_1khz": number,            // EQ 1kHz帯 [-20.0 ～ +20.0] dB
  "eq4_4khz": number,            // EQ 4kHz帯 [-20.0 ～ +20.0] dB
  "eq5_10khz": number,           // EQ 10kHz帯 [-20.0 ～ +20.0] dB
  "reverbDecay": number,         // リバーブ減衰時間 [0.1 ～ 10.0] 秒
  "reverbWet": number            // リバーブのウェット量 [0.00 ～ 1.00]
}

要望: ${prompt}
`
                }]
            }]
        };

const res = await fetch(API_URL, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "X-goog-api-key": API_KEY
  },
  body: JSON.stringify(promptBody)
});

const data = await res.json();
const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "{}";

const jsonText = text
  .replace(/```json\s*/i, "")
  .replace(/```/g, "")
  .trim();

let parsed;
try {
  parsed = JSON.parse(jsonText);
} catch (err) {
  aiStatus.textContent = "AIの出力を解析できませんでした。再試行してください。";
  console.error("JSON parse error:", err, "AI output:", text);
  return;
}

currentAiSettings = parsed;
aiResponseArea.textContent = JSON.stringify(parsed, null, 2);
aiStatus.textContent = "AI設定を取得しました。［設定を適用］を押してください。";
aiApplyBtn.disabled = false;

    } catch (err) {
        console.error(err);
        aiStatus.textContent = `エラー: AIとの通信に失敗しました (${err.message})`;
    }
});


        aiApplyBtn.addEventListener('click', applyAiSettings);


        // --- アナライザ描画 ---
        function drawAnalysers() {
            requestAnimationFrame(drawAnalysers);

            if (!isInitialized) return;

            // Waveform (時間領域)
            const waveData = analyserWave.getValue();
            const waveWidth = waveformCanvas.width;
            const waveHeight = waveformCanvas.height;
            waveformCtx.clearRect(0, 0, waveWidth, waveHeight);
            waveformCtx.lineWidth = 2;
            waveformCtx.strokeStyle = 'rgb(66, 153, 225)'; // Blue-500
            waveformCtx.beginPath();

            const sliceWidth = waveWidth * 1.0 / waveData.length;
            let x = 0;

            for (let i = 0; i < waveData.length; i++) {
                const v = waveData[i];
                const y = (v + 1) / 2 * waveHeight;

                if (i === 0) {
                    waveformCtx.moveTo(x, y);
                } else {
                    waveformCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            waveformCtx.lineTo(waveWidth, waveHeight / 2);
            waveformCtx.stroke();

            // FFT (周波数領域)
            const fftData = analyserFft.getValue();
            const fftWidth = fftCanvas.width;
            const fftHeight = fftCanvas.height;
            fftCtx.clearRect(0, 0, fftWidth, fftHeight);

            const barWidth = (fftWidth / fftData.length) * 2.5;
            let barX = 0;

            for (let i = 0; i < fftData.length; i++) {
                // dB値を高さに変換 (-100dBから0dBの範囲を0から100%にマッピング)
                let percent = (fftData[i] + 100) / 100;
                let barHeight = percent * fftHeight;

                // 最小値を設定してバーが消えないようにする
                barHeight = Math.max(2, barHeight); 

                fftCtx.fillStyle = `rgb(109, 40, 217, ${percent + 0.2})`; // Purple-700
                fftCtx.fillRect(barX, fftHeight - barHeight, barWidth, barHeight);

                barX += barWidth + 1;
            }
        } 
    </script>
</body>
</html>
